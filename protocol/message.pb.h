// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "data.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[103];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultscommand_replyImpl();
void InitDefaultscommand_reply();
void InitDefaultsvalues_typeImpl();
void InitDefaultsvalues_type();
void InitDefaultskeys_typeImpl();
void InitDefaultskeys_type();
void InitDefaultscommand_setImpl();
void InitDefaultscommand_set();
void InitDefaultscommand_mset_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_mset_KvsEntry_DoNotUse();
void InitDefaultscommand_msetImpl();
void InitDefaultscommand_mset();
void InitDefaultscommand_hsetImpl();
void InitDefaultscommand_hset();
void InitDefaultscommand_hmset_ValuesEntry_DoNotUseImpl();
void InitDefaultscommand_hmset_ValuesEntry_DoNotUse();
void InitDefaultscommand_hmsetImpl();
void InitDefaultscommand_hmset();
void InitDefaultscommand_mhmset_ValuesEntry_DoNotUseImpl();
void InitDefaultscommand_mhmset_ValuesEntry_DoNotUse();
void InitDefaultscommand_mhmsetImpl();
void InitDefaultscommand_mhmset();
void InitDefaultscommand_getImpl();
void InitDefaultscommand_get();
void InitDefaultscommand_get_replyImpl();
void InitDefaultscommand_get_reply();
void InitDefaultscommand_mgetImpl();
void InitDefaultscommand_mget();
void InitDefaultscommand_mget_replyImpl();
void InitDefaultscommand_mget_reply();
void InitDefaultscommand_hgetImpl();
void InitDefaultscommand_hget();
void InitDefaultscommand_hget_replyImpl();
void InitDefaultscommand_hget_reply();
void InitDefaultscommand_hmgetImpl();
void InitDefaultscommand_hmget();
void InitDefaultscommand_hmget_replyImpl();
void InitDefaultscommand_hmget_reply();
void InitDefaultscommand_mhmgetImpl();
void InitDefaultscommand_mhmget();
void InitDefaultscommand_mhmget_reply_DataEntry_DoNotUseImpl();
void InitDefaultscommand_mhmget_reply_DataEntry_DoNotUse();
void InitDefaultscommand_mhmget_replyImpl();
void InitDefaultscommand_mhmget_reply();
void InitDefaultscommand_delImpl();
void InitDefaultscommand_del();
void InitDefaultscommand_mdelImpl();
void InitDefaultscommand_mdel();
void InitDefaultscommand_hdelImpl();
void InitDefaultscommand_hdel();
void InitDefaultscommand_hmdelImpl();
void InitDefaultscommand_hmdel();
void InitDefaultscommand_mhmdelImpl();
void InitDefaultscommand_mhmdel();
void InitDefaultscommand_incrImpl();
void InitDefaultscommand_incr();
void InitDefaultscommand_mincr_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_mincr_KvsEntry_DoNotUse();
void InitDefaultscommand_mincrImpl();
void InitDefaultscommand_mincr();
void InitDefaultscommand_hincrImpl();
void InitDefaultscommand_hincr();
void InitDefaultscommand_hmincr_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_hmincr_KvsEntry_DoNotUse();
void InitDefaultscommand_hmincrImpl();
void InitDefaultscommand_hmincr();
void InitDefaultscommand_mhmincr_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_mhmincr_KvsEntry_DoNotUse();
void InitDefaultscommand_mhmincrImpl();
void InitDefaultscommand_mhmincr();
void InitDefaultscommand_lpushImpl();
void InitDefaultscommand_lpush();
void InitDefaultscommand_mlpush_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_mlpush_KvsEntry_DoNotUse();
void InitDefaultscommand_mlpushImpl();
void InitDefaultscommand_mlpush();
void InitDefaultscommand_hlpushImpl();
void InitDefaultscommand_hlpush();
void InitDefaultscommand_hmlpush_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_hmlpush_KvsEntry_DoNotUse();
void InitDefaultscommand_hmlpushImpl();
void InitDefaultscommand_hmlpush();
void InitDefaultscommand_mhmlpush_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_mhmlpush_KvsEntry_DoNotUse();
void InitDefaultscommand_mhmlpushImpl();
void InitDefaultscommand_mhmlpush();
void InitDefaultscommand_lrangeImpl();
void InitDefaultscommand_lrange();
void InitDefaultscommand_lrange_replyImpl();
void InitDefaultscommand_lrange_reply();
void InitDefaultscommand_mlrangeImpl();
void InitDefaultscommand_mlrange();
void InitDefaultscommand_mlrange_replyImpl();
void InitDefaultscommand_mlrange_reply();
void InitDefaultscommand_hlrangeImpl();
void InitDefaultscommand_hlrange();
void InitDefaultscommand_hlrange_replyImpl();
void InitDefaultscommand_hlrange_reply();
void InitDefaultscommand_hmlrangeImpl();
void InitDefaultscommand_hmlrange();
void InitDefaultscommand_hmlrange_replyImpl();
void InitDefaultscommand_hmlrange_reply();
void InitDefaultscommand_mhmlrangeImpl();
void InitDefaultscommand_mhmlrange();
void InitDefaultscommand_mhmlrange_replyImpl();
void InitDefaultscommand_mhmlrange_reply();
void InitDefaultscommand_lpopImpl();
void InitDefaultscommand_lpop();
void InitDefaultscommand_lpop_replyImpl();
void InitDefaultscommand_lpop_reply();
void InitDefaultscommand_mlpopImpl();
void InitDefaultscommand_mlpop();
void InitDefaultscommand_mlpop_repyImpl();
void InitDefaultscommand_mlpop_repy();
void InitDefaultscommand_hlpopImpl();
void InitDefaultscommand_hlpop();
void InitDefaultscommand_hlpop_replyImpl();
void InitDefaultscommand_hlpop_reply();
void InitDefaultscommand_hmlpopImpl();
void InitDefaultscommand_hmlpop();
void InitDefaultscommand_hmlpop_replyImpl();
void InitDefaultscommand_hmlpop_reply();
void InitDefaultscommand_mhmlpopImpl();
void InitDefaultscommand_mhmlpop();
void InitDefaultscommand_mhmlpop_replyImpl();
void InitDefaultscommand_mhmlpop_reply();
void InitDefaultscommand_ltrimImpl();
void InitDefaultscommand_ltrim();
void InitDefaultscommand_mltrimImpl();
void InitDefaultscommand_mltrim();
void InitDefaultscommand_hltrimImpl();
void InitDefaultscommand_hltrim();
void InitDefaultscommand_hmltrimImpl();
void InitDefaultscommand_hmltrim();
void InitDefaultscommand_mhmltrimImpl();
void InitDefaultscommand_mhmltrim();
void InitDefaultscommand_llenImpl();
void InitDefaultscommand_llen();
void InitDefaultscommand_llen_replyImpl();
void InitDefaultscommand_llen_reply();
void InitDefaultscommand_mllenImpl();
void InitDefaultscommand_mllen();
void InitDefaultscommand_mllen_replyImpl();
void InitDefaultscommand_mllen_reply();
void InitDefaultscommand_hllenImpl();
void InitDefaultscommand_hllen();
void InitDefaultscommand_hllen_replyImpl();
void InitDefaultscommand_hllen_reply();
void InitDefaultscommand_hmllenImpl();
void InitDefaultscommand_hmllen();
void InitDefaultscommand_hmllen_replyImpl();
void InitDefaultscommand_hmllen_reply();
void InitDefaultscommand_mhmllenImpl();
void InitDefaultscommand_mhmllen();
void InitDefaultscommand_mhmllen_replyImpl();
void InitDefaultscommand_mhmllen_reply();
void InitDefaultscommand_mapgetImpl();
void InitDefaultscommand_mapget();
void InitDefaultscommand_mapget_replyImpl();
void InitDefaultscommand_mapget_reply();
void InitDefaultscommand_mmapgetImpl();
void InitDefaultscommand_mmapget();
void InitDefaultscommand_mmapget_replyImpl();
void InitDefaultscommand_mmapget_reply();
void InitDefaultscommand_hmapgetImpl();
void InitDefaultscommand_hmapget();
void InitDefaultscommand_hmapget_replyImpl();
void InitDefaultscommand_hmapget_reply();
void InitDefaultscommand_hmmapgetImpl();
void InitDefaultscommand_hmmapget();
void InitDefaultscommand_hmmapget_replyImpl();
void InitDefaultscommand_hmmapget_reply();
void InitDefaultscommand_mhmmapgetImpl();
void InitDefaultscommand_mhmmapget();
void InitDefaultscommand_mhmmapget_replyImpl();
void InitDefaultscommand_mhmmapget_reply();
void InitDefaultscommand_mapsetImpl();
void InitDefaultscommand_mapset();
void InitDefaultscommand_mmapset_KvsEntry_DoNotUseImpl();
void InitDefaultscommand_mmapset_KvsEntry_DoNotUse();
void InitDefaultscommand_mmapsetImpl();
void InitDefaultscommand_mmapset();
void InitDefaultscommand_hmapsetImpl();
void InitDefaultscommand_hmapset();
void InitDefaultscommand_hmmapset_ValuesEntry_DoNotUseImpl();
void InitDefaultscommand_hmmapset_ValuesEntry_DoNotUse();
void InitDefaultscommand_hmmapsetImpl();
void InitDefaultscommand_hmmapset();
void InitDefaultscommand_mhmmapset_ValuesEntry_DoNotUseImpl();
void InitDefaultscommand_mhmmapset_ValuesEntry_DoNotUse();
void InitDefaultscommand_mhmmapsetImpl();
void InitDefaultscommand_mhmmapset();
void InitDefaultscommand_mapdelImpl();
void InitDefaultscommand_mapdel();
void InitDefaultscommand_mmapdelImpl();
void InitDefaultscommand_mmapdel();
void InitDefaultscommand_hmapdelImpl();
void InitDefaultscommand_hmapdel();
void InitDefaultscommand_hmmapdelImpl();
void InitDefaultscommand_hmmapdel();
void InitDefaultscommand_mhmmapdel_ValuesEntry_DoNotUseImpl();
void InitDefaultscommand_mhmmapdel_ValuesEntry_DoNotUse();
void InitDefaultscommand_mhmmapdelImpl();
void InitDefaultscommand_mhmmapdel();
void InitDefaultscommand_meetImpl();
void InitDefaultscommand_meet();
inline void InitDefaults() {
  InitDefaultscommand_reply();
  InitDefaultsvalues_type();
  InitDefaultskeys_type();
  InitDefaultscommand_set();
  InitDefaultscommand_mset_KvsEntry_DoNotUse();
  InitDefaultscommand_mset();
  InitDefaultscommand_hset();
  InitDefaultscommand_hmset_ValuesEntry_DoNotUse();
  InitDefaultscommand_hmset();
  InitDefaultscommand_mhmset_ValuesEntry_DoNotUse();
  InitDefaultscommand_mhmset();
  InitDefaultscommand_get();
  InitDefaultscommand_get_reply();
  InitDefaultscommand_mget();
  InitDefaultscommand_mget_reply();
  InitDefaultscommand_hget();
  InitDefaultscommand_hget_reply();
  InitDefaultscommand_hmget();
  InitDefaultscommand_hmget_reply();
  InitDefaultscommand_mhmget();
  InitDefaultscommand_mhmget_reply_DataEntry_DoNotUse();
  InitDefaultscommand_mhmget_reply();
  InitDefaultscommand_del();
  InitDefaultscommand_mdel();
  InitDefaultscommand_hdel();
  InitDefaultscommand_hmdel();
  InitDefaultscommand_mhmdel();
  InitDefaultscommand_incr();
  InitDefaultscommand_mincr_KvsEntry_DoNotUse();
  InitDefaultscommand_mincr();
  InitDefaultscommand_hincr();
  InitDefaultscommand_hmincr_KvsEntry_DoNotUse();
  InitDefaultscommand_hmincr();
  InitDefaultscommand_mhmincr_KvsEntry_DoNotUse();
  InitDefaultscommand_mhmincr();
  InitDefaultscommand_lpush();
  InitDefaultscommand_mlpush_KvsEntry_DoNotUse();
  InitDefaultscommand_mlpush();
  InitDefaultscommand_hlpush();
  InitDefaultscommand_hmlpush_KvsEntry_DoNotUse();
  InitDefaultscommand_hmlpush();
  InitDefaultscommand_mhmlpush_KvsEntry_DoNotUse();
  InitDefaultscommand_mhmlpush();
  InitDefaultscommand_lrange();
  InitDefaultscommand_lrange_reply();
  InitDefaultscommand_mlrange();
  InitDefaultscommand_mlrange_reply();
  InitDefaultscommand_hlrange();
  InitDefaultscommand_hlrange_reply();
  InitDefaultscommand_hmlrange();
  InitDefaultscommand_hmlrange_reply();
  InitDefaultscommand_mhmlrange();
  InitDefaultscommand_mhmlrange_reply();
  InitDefaultscommand_lpop();
  InitDefaultscommand_lpop_reply();
  InitDefaultscommand_mlpop();
  InitDefaultscommand_mlpop_repy();
  InitDefaultscommand_hlpop();
  InitDefaultscommand_hlpop_reply();
  InitDefaultscommand_hmlpop();
  InitDefaultscommand_hmlpop_reply();
  InitDefaultscommand_mhmlpop();
  InitDefaultscommand_mhmlpop_reply();
  InitDefaultscommand_ltrim();
  InitDefaultscommand_mltrim();
  InitDefaultscommand_hltrim();
  InitDefaultscommand_hmltrim();
  InitDefaultscommand_mhmltrim();
  InitDefaultscommand_llen();
  InitDefaultscommand_llen_reply();
  InitDefaultscommand_mllen();
  InitDefaultscommand_mllen_reply();
  InitDefaultscommand_hllen();
  InitDefaultscommand_hllen_reply();
  InitDefaultscommand_hmllen();
  InitDefaultscommand_hmllen_reply();
  InitDefaultscommand_mhmllen();
  InitDefaultscommand_mhmllen_reply();
  InitDefaultscommand_mapget();
  InitDefaultscommand_mapget_reply();
  InitDefaultscommand_mmapget();
  InitDefaultscommand_mmapget_reply();
  InitDefaultscommand_hmapget();
  InitDefaultscommand_hmapget_reply();
  InitDefaultscommand_hmmapget();
  InitDefaultscommand_hmmapget_reply();
  InitDefaultscommand_mhmmapget();
  InitDefaultscommand_mhmmapget_reply();
  InitDefaultscommand_mapset();
  InitDefaultscommand_mmapset_KvsEntry_DoNotUse();
  InitDefaultscommand_mmapset();
  InitDefaultscommand_hmapset();
  InitDefaultscommand_hmmapset_ValuesEntry_DoNotUse();
  InitDefaultscommand_hmmapset();
  InitDefaultscommand_mhmmapset_ValuesEntry_DoNotUse();
  InitDefaultscommand_mhmmapset();
  InitDefaultscommand_mapdel();
  InitDefaultscommand_mmapdel();
  InitDefaultscommand_hmapdel();
  InitDefaultscommand_hmmapdel();
  InitDefaultscommand_mhmmapdel_ValuesEntry_DoNotUse();
  InitDefaultscommand_mhmmapdel();
  InitDefaultscommand_meet();
}
}  // namespace protobuf_message_2eproto
namespace client {
class command_del;
class command_delDefaultTypeInternal;
extern command_delDefaultTypeInternal _command_del_default_instance_;
class command_get;
class command_getDefaultTypeInternal;
extern command_getDefaultTypeInternal _command_get_default_instance_;
class command_get_reply;
class command_get_replyDefaultTypeInternal;
extern command_get_replyDefaultTypeInternal _command_get_reply_default_instance_;
class command_hdel;
class command_hdelDefaultTypeInternal;
extern command_hdelDefaultTypeInternal _command_hdel_default_instance_;
class command_hget;
class command_hgetDefaultTypeInternal;
extern command_hgetDefaultTypeInternal _command_hget_default_instance_;
class command_hget_reply;
class command_hget_replyDefaultTypeInternal;
extern command_hget_replyDefaultTypeInternal _command_hget_reply_default_instance_;
class command_hincr;
class command_hincrDefaultTypeInternal;
extern command_hincrDefaultTypeInternal _command_hincr_default_instance_;
class command_hllen;
class command_hllenDefaultTypeInternal;
extern command_hllenDefaultTypeInternal _command_hllen_default_instance_;
class command_hllen_reply;
class command_hllen_replyDefaultTypeInternal;
extern command_hllen_replyDefaultTypeInternal _command_hllen_reply_default_instance_;
class command_hlpop;
class command_hlpopDefaultTypeInternal;
extern command_hlpopDefaultTypeInternal _command_hlpop_default_instance_;
class command_hlpop_reply;
class command_hlpop_replyDefaultTypeInternal;
extern command_hlpop_replyDefaultTypeInternal _command_hlpop_reply_default_instance_;
class command_hlpush;
class command_hlpushDefaultTypeInternal;
extern command_hlpushDefaultTypeInternal _command_hlpush_default_instance_;
class command_hlrange;
class command_hlrangeDefaultTypeInternal;
extern command_hlrangeDefaultTypeInternal _command_hlrange_default_instance_;
class command_hlrange_reply;
class command_hlrange_replyDefaultTypeInternal;
extern command_hlrange_replyDefaultTypeInternal _command_hlrange_reply_default_instance_;
class command_hltrim;
class command_hltrimDefaultTypeInternal;
extern command_hltrimDefaultTypeInternal _command_hltrim_default_instance_;
class command_hmapdel;
class command_hmapdelDefaultTypeInternal;
extern command_hmapdelDefaultTypeInternal _command_hmapdel_default_instance_;
class command_hmapget;
class command_hmapgetDefaultTypeInternal;
extern command_hmapgetDefaultTypeInternal _command_hmapget_default_instance_;
class command_hmapget_reply;
class command_hmapget_replyDefaultTypeInternal;
extern command_hmapget_replyDefaultTypeInternal _command_hmapget_reply_default_instance_;
class command_hmapset;
class command_hmapsetDefaultTypeInternal;
extern command_hmapsetDefaultTypeInternal _command_hmapset_default_instance_;
class command_hmdel;
class command_hmdelDefaultTypeInternal;
extern command_hmdelDefaultTypeInternal _command_hmdel_default_instance_;
class command_hmget;
class command_hmgetDefaultTypeInternal;
extern command_hmgetDefaultTypeInternal _command_hmget_default_instance_;
class command_hmget_reply;
class command_hmget_replyDefaultTypeInternal;
extern command_hmget_replyDefaultTypeInternal _command_hmget_reply_default_instance_;
class command_hmincr;
class command_hmincrDefaultTypeInternal;
extern command_hmincrDefaultTypeInternal _command_hmincr_default_instance_;
class command_hmincr_KvsEntry_DoNotUse;
class command_hmincr_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_hmincr_KvsEntry_DoNotUseDefaultTypeInternal _command_hmincr_KvsEntry_DoNotUse_default_instance_;
class command_hmllen;
class command_hmllenDefaultTypeInternal;
extern command_hmllenDefaultTypeInternal _command_hmllen_default_instance_;
class command_hmllen_reply;
class command_hmllen_replyDefaultTypeInternal;
extern command_hmllen_replyDefaultTypeInternal _command_hmllen_reply_default_instance_;
class command_hmlpop;
class command_hmlpopDefaultTypeInternal;
extern command_hmlpopDefaultTypeInternal _command_hmlpop_default_instance_;
class command_hmlpop_reply;
class command_hmlpop_replyDefaultTypeInternal;
extern command_hmlpop_replyDefaultTypeInternal _command_hmlpop_reply_default_instance_;
class command_hmlpush;
class command_hmlpushDefaultTypeInternal;
extern command_hmlpushDefaultTypeInternal _command_hmlpush_default_instance_;
class command_hmlpush_KvsEntry_DoNotUse;
class command_hmlpush_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_hmlpush_KvsEntry_DoNotUseDefaultTypeInternal _command_hmlpush_KvsEntry_DoNotUse_default_instance_;
class command_hmlrange;
class command_hmlrangeDefaultTypeInternal;
extern command_hmlrangeDefaultTypeInternal _command_hmlrange_default_instance_;
class command_hmlrange_reply;
class command_hmlrange_replyDefaultTypeInternal;
extern command_hmlrange_replyDefaultTypeInternal _command_hmlrange_reply_default_instance_;
class command_hmltrim;
class command_hmltrimDefaultTypeInternal;
extern command_hmltrimDefaultTypeInternal _command_hmltrim_default_instance_;
class command_hmmapdel;
class command_hmmapdelDefaultTypeInternal;
extern command_hmmapdelDefaultTypeInternal _command_hmmapdel_default_instance_;
class command_hmmapget;
class command_hmmapgetDefaultTypeInternal;
extern command_hmmapgetDefaultTypeInternal _command_hmmapget_default_instance_;
class command_hmmapget_reply;
class command_hmmapget_replyDefaultTypeInternal;
extern command_hmmapget_replyDefaultTypeInternal _command_hmmapget_reply_default_instance_;
class command_hmmapset;
class command_hmmapsetDefaultTypeInternal;
extern command_hmmapsetDefaultTypeInternal _command_hmmapset_default_instance_;
class command_hmmapset_ValuesEntry_DoNotUse;
class command_hmmapset_ValuesEntry_DoNotUseDefaultTypeInternal;
extern command_hmmapset_ValuesEntry_DoNotUseDefaultTypeInternal _command_hmmapset_ValuesEntry_DoNotUse_default_instance_;
class command_hmset;
class command_hmsetDefaultTypeInternal;
extern command_hmsetDefaultTypeInternal _command_hmset_default_instance_;
class command_hmset_ValuesEntry_DoNotUse;
class command_hmset_ValuesEntry_DoNotUseDefaultTypeInternal;
extern command_hmset_ValuesEntry_DoNotUseDefaultTypeInternal _command_hmset_ValuesEntry_DoNotUse_default_instance_;
class command_hset;
class command_hsetDefaultTypeInternal;
extern command_hsetDefaultTypeInternal _command_hset_default_instance_;
class command_incr;
class command_incrDefaultTypeInternal;
extern command_incrDefaultTypeInternal _command_incr_default_instance_;
class command_llen;
class command_llenDefaultTypeInternal;
extern command_llenDefaultTypeInternal _command_llen_default_instance_;
class command_llen_reply;
class command_llen_replyDefaultTypeInternal;
extern command_llen_replyDefaultTypeInternal _command_llen_reply_default_instance_;
class command_lpop;
class command_lpopDefaultTypeInternal;
extern command_lpopDefaultTypeInternal _command_lpop_default_instance_;
class command_lpop_reply;
class command_lpop_replyDefaultTypeInternal;
extern command_lpop_replyDefaultTypeInternal _command_lpop_reply_default_instance_;
class command_lpush;
class command_lpushDefaultTypeInternal;
extern command_lpushDefaultTypeInternal _command_lpush_default_instance_;
class command_lrange;
class command_lrangeDefaultTypeInternal;
extern command_lrangeDefaultTypeInternal _command_lrange_default_instance_;
class command_lrange_reply;
class command_lrange_replyDefaultTypeInternal;
extern command_lrange_replyDefaultTypeInternal _command_lrange_reply_default_instance_;
class command_ltrim;
class command_ltrimDefaultTypeInternal;
extern command_ltrimDefaultTypeInternal _command_ltrim_default_instance_;
class command_mapdel;
class command_mapdelDefaultTypeInternal;
extern command_mapdelDefaultTypeInternal _command_mapdel_default_instance_;
class command_mapget;
class command_mapgetDefaultTypeInternal;
extern command_mapgetDefaultTypeInternal _command_mapget_default_instance_;
class command_mapget_reply;
class command_mapget_replyDefaultTypeInternal;
extern command_mapget_replyDefaultTypeInternal _command_mapget_reply_default_instance_;
class command_mapset;
class command_mapsetDefaultTypeInternal;
extern command_mapsetDefaultTypeInternal _command_mapset_default_instance_;
class command_mdel;
class command_mdelDefaultTypeInternal;
extern command_mdelDefaultTypeInternal _command_mdel_default_instance_;
class command_meet;
class command_meetDefaultTypeInternal;
extern command_meetDefaultTypeInternal _command_meet_default_instance_;
class command_mget;
class command_mgetDefaultTypeInternal;
extern command_mgetDefaultTypeInternal _command_mget_default_instance_;
class command_mget_reply;
class command_mget_replyDefaultTypeInternal;
extern command_mget_replyDefaultTypeInternal _command_mget_reply_default_instance_;
class command_mhmdel;
class command_mhmdelDefaultTypeInternal;
extern command_mhmdelDefaultTypeInternal _command_mhmdel_default_instance_;
class command_mhmget;
class command_mhmgetDefaultTypeInternal;
extern command_mhmgetDefaultTypeInternal _command_mhmget_default_instance_;
class command_mhmget_reply;
class command_mhmget_replyDefaultTypeInternal;
extern command_mhmget_replyDefaultTypeInternal _command_mhmget_reply_default_instance_;
class command_mhmget_reply_DataEntry_DoNotUse;
class command_mhmget_reply_DataEntry_DoNotUseDefaultTypeInternal;
extern command_mhmget_reply_DataEntry_DoNotUseDefaultTypeInternal _command_mhmget_reply_DataEntry_DoNotUse_default_instance_;
class command_mhmincr;
class command_mhmincrDefaultTypeInternal;
extern command_mhmincrDefaultTypeInternal _command_mhmincr_default_instance_;
class command_mhmincr_KvsEntry_DoNotUse;
class command_mhmincr_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_mhmincr_KvsEntry_DoNotUseDefaultTypeInternal _command_mhmincr_KvsEntry_DoNotUse_default_instance_;
class command_mhmllen;
class command_mhmllenDefaultTypeInternal;
extern command_mhmllenDefaultTypeInternal _command_mhmllen_default_instance_;
class command_mhmllen_reply;
class command_mhmllen_replyDefaultTypeInternal;
extern command_mhmllen_replyDefaultTypeInternal _command_mhmllen_reply_default_instance_;
class command_mhmlpop;
class command_mhmlpopDefaultTypeInternal;
extern command_mhmlpopDefaultTypeInternal _command_mhmlpop_default_instance_;
class command_mhmlpop_reply;
class command_mhmlpop_replyDefaultTypeInternal;
extern command_mhmlpop_replyDefaultTypeInternal _command_mhmlpop_reply_default_instance_;
class command_mhmlpush;
class command_mhmlpushDefaultTypeInternal;
extern command_mhmlpushDefaultTypeInternal _command_mhmlpush_default_instance_;
class command_mhmlpush_KvsEntry_DoNotUse;
class command_mhmlpush_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_mhmlpush_KvsEntry_DoNotUseDefaultTypeInternal _command_mhmlpush_KvsEntry_DoNotUse_default_instance_;
class command_mhmlrange;
class command_mhmlrangeDefaultTypeInternal;
extern command_mhmlrangeDefaultTypeInternal _command_mhmlrange_default_instance_;
class command_mhmlrange_reply;
class command_mhmlrange_replyDefaultTypeInternal;
extern command_mhmlrange_replyDefaultTypeInternal _command_mhmlrange_reply_default_instance_;
class command_mhmltrim;
class command_mhmltrimDefaultTypeInternal;
extern command_mhmltrimDefaultTypeInternal _command_mhmltrim_default_instance_;
class command_mhmmapdel;
class command_mhmmapdelDefaultTypeInternal;
extern command_mhmmapdelDefaultTypeInternal _command_mhmmapdel_default_instance_;
class command_mhmmapdel_ValuesEntry_DoNotUse;
class command_mhmmapdel_ValuesEntry_DoNotUseDefaultTypeInternal;
extern command_mhmmapdel_ValuesEntry_DoNotUseDefaultTypeInternal _command_mhmmapdel_ValuesEntry_DoNotUse_default_instance_;
class command_mhmmapget;
class command_mhmmapgetDefaultTypeInternal;
extern command_mhmmapgetDefaultTypeInternal _command_mhmmapget_default_instance_;
class command_mhmmapget_reply;
class command_mhmmapget_replyDefaultTypeInternal;
extern command_mhmmapget_replyDefaultTypeInternal _command_mhmmapget_reply_default_instance_;
class command_mhmmapset;
class command_mhmmapsetDefaultTypeInternal;
extern command_mhmmapsetDefaultTypeInternal _command_mhmmapset_default_instance_;
class command_mhmmapset_ValuesEntry_DoNotUse;
class command_mhmmapset_ValuesEntry_DoNotUseDefaultTypeInternal;
extern command_mhmmapset_ValuesEntry_DoNotUseDefaultTypeInternal _command_mhmmapset_ValuesEntry_DoNotUse_default_instance_;
class command_mhmset;
class command_mhmsetDefaultTypeInternal;
extern command_mhmsetDefaultTypeInternal _command_mhmset_default_instance_;
class command_mhmset_ValuesEntry_DoNotUse;
class command_mhmset_ValuesEntry_DoNotUseDefaultTypeInternal;
extern command_mhmset_ValuesEntry_DoNotUseDefaultTypeInternal _command_mhmset_ValuesEntry_DoNotUse_default_instance_;
class command_mincr;
class command_mincrDefaultTypeInternal;
extern command_mincrDefaultTypeInternal _command_mincr_default_instance_;
class command_mincr_KvsEntry_DoNotUse;
class command_mincr_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_mincr_KvsEntry_DoNotUseDefaultTypeInternal _command_mincr_KvsEntry_DoNotUse_default_instance_;
class command_mllen;
class command_mllenDefaultTypeInternal;
extern command_mllenDefaultTypeInternal _command_mllen_default_instance_;
class command_mllen_reply;
class command_mllen_replyDefaultTypeInternal;
extern command_mllen_replyDefaultTypeInternal _command_mllen_reply_default_instance_;
class command_mlpop;
class command_mlpopDefaultTypeInternal;
extern command_mlpopDefaultTypeInternal _command_mlpop_default_instance_;
class command_mlpop_repy;
class command_mlpop_repyDefaultTypeInternal;
extern command_mlpop_repyDefaultTypeInternal _command_mlpop_repy_default_instance_;
class command_mlpush;
class command_mlpushDefaultTypeInternal;
extern command_mlpushDefaultTypeInternal _command_mlpush_default_instance_;
class command_mlpush_KvsEntry_DoNotUse;
class command_mlpush_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_mlpush_KvsEntry_DoNotUseDefaultTypeInternal _command_mlpush_KvsEntry_DoNotUse_default_instance_;
class command_mlrange;
class command_mlrangeDefaultTypeInternal;
extern command_mlrangeDefaultTypeInternal _command_mlrange_default_instance_;
class command_mlrange_reply;
class command_mlrange_replyDefaultTypeInternal;
extern command_mlrange_replyDefaultTypeInternal _command_mlrange_reply_default_instance_;
class command_mltrim;
class command_mltrimDefaultTypeInternal;
extern command_mltrimDefaultTypeInternal _command_mltrim_default_instance_;
class command_mmapdel;
class command_mmapdelDefaultTypeInternal;
extern command_mmapdelDefaultTypeInternal _command_mmapdel_default_instance_;
class command_mmapget;
class command_mmapgetDefaultTypeInternal;
extern command_mmapgetDefaultTypeInternal _command_mmapget_default_instance_;
class command_mmapget_reply;
class command_mmapget_replyDefaultTypeInternal;
extern command_mmapget_replyDefaultTypeInternal _command_mmapget_reply_default_instance_;
class command_mmapset;
class command_mmapsetDefaultTypeInternal;
extern command_mmapsetDefaultTypeInternal _command_mmapset_default_instance_;
class command_mmapset_KvsEntry_DoNotUse;
class command_mmapset_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_mmapset_KvsEntry_DoNotUseDefaultTypeInternal _command_mmapset_KvsEntry_DoNotUse_default_instance_;
class command_mset;
class command_msetDefaultTypeInternal;
extern command_msetDefaultTypeInternal _command_mset_default_instance_;
class command_mset_KvsEntry_DoNotUse;
class command_mset_KvsEntry_DoNotUseDefaultTypeInternal;
extern command_mset_KvsEntry_DoNotUseDefaultTypeInternal _command_mset_KvsEntry_DoNotUse_default_instance_;
class command_reply;
class command_replyDefaultTypeInternal;
extern command_replyDefaultTypeInternal _command_reply_default_instance_;
class command_set;
class command_setDefaultTypeInternal;
extern command_setDefaultTypeInternal _command_set_default_instance_;
class keys_type;
class keys_typeDefaultTypeInternal;
extern keys_typeDefaultTypeInternal _keys_type_default_instance_;
class values_type;
class values_typeDefaultTypeInternal;
extern values_typeDefaultTypeInternal _values_type_default_instance_;
}  // namespace client
namespace client {

enum type {
  UNKNOW = 0,
  NOT_FOUND = 1,
  HSET = 2,
  HGET = 3,
  type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool type_IsValid(int value);
const type type_MIN = UNKNOW;
const type type_MAX = HGET;
const int type_ARRAYSIZE = type_MAX + 1;

const ::google::protobuf::EnumDescriptor* type_descriptor();
inline const ::std::string& type_Name(type value) {
  return ::google::protobuf::internal::NameOfEnum(
    type_descriptor(), value);
}
inline bool type_Parse(
    const ::std::string& name, type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<type>(
    type_descriptor(), name, value);
}
// ===================================================================

class command_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_reply) */ {
 public:
  command_reply();
  virtual ~command_reply();

  command_reply(const command_reply& from);

  inline command_reply& operator=(const command_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_reply(command_reply&& from) noexcept
    : command_reply() {
    *this = ::std::move(from);
  }

  inline command_reply& operator=(command_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_reply* internal_default_instance() {
    return reinterpret_cast<const command_reply*>(
               &_command_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(command_reply* other);
  friend void swap(command_reply& a, command_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_reply& from);
  void MergeFrom(const command_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string errmsg = 2;
  void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // int32 errcode = 1;
  void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  ::google::protobuf::int32 errcode_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_replyImpl();
};
// -------------------------------------------------------------------

class values_type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.values_type) */ {
 public:
  values_type();
  virtual ~values_type();

  values_type(const values_type& from);

  inline values_type& operator=(const values_type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  values_type(values_type&& from) noexcept
    : values_type() {
    *this = ::std::move(from);
  }

  inline values_type& operator=(values_type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const values_type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const values_type* internal_default_instance() {
    return reinterpret_cast<const values_type*>(
               &_values_type_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(values_type* other);
  friend void swap(values_type& a, values_type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline values_type* New() const PROTOBUF_FINAL { return New(NULL); }

  values_type* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const values_type& from);
  void MergeFrom(const values_type& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(values_type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::data::VALUE& value(int index) const;
  ::data::VALUE* mutable_value(int index);
  ::data::VALUE* add_value();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      value() const;

  // @@protoc_insertion_point(class_scope:client.values_type)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsvalues_typeImpl();
};
// -------------------------------------------------------------------

class keys_type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.keys_type) */ {
 public:
  keys_type();
  virtual ~keys_type();

  keys_type(const keys_type& from);

  inline keys_type& operator=(const keys_type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  keys_type(keys_type&& from) noexcept
    : keys_type() {
    *this = ::std::move(from);
  }

  inline keys_type& operator=(keys_type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const keys_type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const keys_type* internal_default_instance() {
    return reinterpret_cast<const keys_type*>(
               &_keys_type_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(keys_type* other);
  friend void swap(keys_type& a, keys_type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline keys_type* New() const PROTOBUF_FINAL { return New(NULL); }

  keys_type* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const keys_type& from);
  void MergeFrom(const keys_type& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(keys_type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:client.keys_type)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultskeys_typeImpl();
};
// -------------------------------------------------------------------

class command_set : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_set) */ {
 public:
  command_set();
  virtual ~command_set();

  command_set(const command_set& from);

  inline command_set& operator=(const command_set& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_set(command_set&& from) noexcept
    : command_set() {
    *this = ::std::move(from);
  }

  inline command_set& operator=(command_set&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_set& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_set* internal_default_instance() {
    return reinterpret_cast<const command_set*>(
               &_command_set_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(command_set* other);
  friend void swap(command_set& a, command_set& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_set* New() const PROTOBUF_FINAL { return New(NULL); }

  command_set* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_set& from);
  void MergeFrom(const command_set& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_set* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .data.VALUE value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_set)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_setImpl();
};
// -------------------------------------------------------------------

class command_mset_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mset_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mset_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mset_KvsEntry_DoNotUse();
  command_mset_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mset_KvsEntry_DoNotUse& other);
  static const command_mset_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mset_KvsEntry_DoNotUse*>(&_command_mset_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mset) */ {
 public:
  command_mset();
  virtual ~command_mset();

  command_mset(const command_mset& from);

  inline command_mset& operator=(const command_mset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mset(command_mset&& from) noexcept
    : command_mset() {
    *this = ::std::move(from);
  }

  inline command_mset& operator=(command_mset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mset* internal_default_instance() {
    return reinterpret_cast<const command_mset*>(
               &_command_mset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(command_mset* other);
  friend void swap(command_mset& a, command_mset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mset& from);
  void MergeFrom(const command_mset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> kvs = 1;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:client.command_mset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_mset_KvsEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_msetImpl();
};
// -------------------------------------------------------------------

class command_hset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hset) */ {
 public:
  command_hset();
  virtual ~command_hset();

  command_hset(const command_hset& from);

  inline command_hset& operator=(const command_hset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hset(command_hset&& from) noexcept
    : command_hset() {
    *this = ::std::move(from);
  }

  inline command_hset& operator=(command_hset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hset* internal_default_instance() {
    return reinterpret_cast<const command_hset*>(
               &_command_hset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(command_hset* other);
  friend void swap(command_hset& a, command_hset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hset& from);
  void MergeFrom(const command_hset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // .data.VALUE value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // int64 ttl = 4;
  void clear_ttl();
  static const int kTtlFieldNumber = 4;
  ::google::protobuf::int64 ttl() const;
  void set_ttl(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:client.command_hset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::data::VALUE* value_;
  ::google::protobuf::int64 ttl_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hsetImpl();
};
// -------------------------------------------------------------------

class command_hmset_ValuesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_hmset_ValuesEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_hmset_ValuesEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_hmset_ValuesEntry_DoNotUse();
  command_hmset_ValuesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_hmset_ValuesEntry_DoNotUse& other);
  static const command_hmset_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_hmset_ValuesEntry_DoNotUse*>(&_command_hmset_ValuesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_hmset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmset) */ {
 public:
  command_hmset();
  virtual ~command_hmset();

  command_hmset(const command_hmset& from);

  inline command_hmset& operator=(const command_hmset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmset(command_hmset&& from) noexcept
    : command_hmset() {
    *this = ::std::move(from);
  }

  inline command_hmset& operator=(command_hmset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmset* internal_default_instance() {
    return reinterpret_cast<const command_hmset*>(
               &_command_hmset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(command_hmset* other);
  friend void swap(command_hmset& a, command_hmset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmset& from);
  void MergeFrom(const command_hmset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      values() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_values();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_hmset_ValuesEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > values_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmsetImpl();
};
// -------------------------------------------------------------------

class command_mhmset_ValuesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mhmset_ValuesEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mhmset_ValuesEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mhmset_ValuesEntry_DoNotUse();
  command_mhmset_ValuesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mhmset_ValuesEntry_DoNotUse& other);
  static const command_mhmset_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mhmset_ValuesEntry_DoNotUse*>(&_command_mhmset_ValuesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mhmset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmset) */ {
 public:
  command_mhmset();
  virtual ~command_mhmset();

  command_mhmset(const command_mhmset& from);

  inline command_mhmset& operator=(const command_mhmset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmset(command_mhmset&& from) noexcept
    : command_mhmset() {
    *this = ::std::move(from);
  }

  inline command_mhmset& operator=(command_mhmset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmset* internal_default_instance() {
    return reinterpret_cast<const command_mhmset*>(
               &_command_mhmset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(command_mhmset* other);
  friend void swap(command_mhmset& a, command_mhmset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmset& from);
  void MergeFrom(const command_mhmset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // map<string, .client.values_type> values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::client::values_type >&
      values() const;
  ::google::protobuf::Map< ::std::string, ::client::values_type >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:client.command_mhmset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::MapField<
      command_mhmset_ValuesEntry_DoNotUse,
      ::std::string, ::client::values_type,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > values_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmsetImpl();
};
// -------------------------------------------------------------------

class command_get : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_get) */ {
 public:
  command_get();
  virtual ~command_get();

  command_get(const command_get& from);

  inline command_get& operator=(const command_get& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_get(command_get&& from) noexcept
    : command_get() {
    *this = ::std::move(from);
  }

  inline command_get& operator=(command_get&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_get& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_get* internal_default_instance() {
    return reinterpret_cast<const command_get*>(
               &_command_get_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(command_get* other);
  friend void swap(command_get& a, command_get& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_get* New() const PROTOBUF_FINAL { return New(NULL); }

  command_get* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_get& from);
  void MergeFrom(const command_get& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_get* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_get)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_getImpl();
};
// -------------------------------------------------------------------

class command_get_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_get_reply) */ {
 public:
  command_get_reply();
  virtual ~command_get_reply();

  command_get_reply(const command_get_reply& from);

  inline command_get_reply& operator=(const command_get_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_get_reply(command_get_reply&& from) noexcept
    : command_get_reply() {
    *this = ::std::move(from);
  }

  inline command_get_reply& operator=(command_get_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_get_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_get_reply* internal_default_instance() {
    return reinterpret_cast<const command_get_reply*>(
               &_command_get_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(command_get_reply* other);
  friend void swap(command_get_reply& a, command_get_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_get_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_get_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_get_reply& from);
  void MergeFrom(const command_get_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_get_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_get_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_get_replyImpl();
};
// -------------------------------------------------------------------

class command_mget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mget) */ {
 public:
  command_mget();
  virtual ~command_mget();

  command_mget(const command_mget& from);

  inline command_mget& operator=(const command_mget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mget(command_mget&& from) noexcept
    : command_mget() {
    *this = ::std::move(from);
  }

  inline command_mget& operator=(command_mget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mget* internal_default_instance() {
    return reinterpret_cast<const command_mget*>(
               &_command_mget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(command_mget* other);
  friend void swap(command_mget& a, command_mget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mget& from);
  void MergeFrom(const command_mget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:client.command_mget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mgetImpl();
};
// -------------------------------------------------------------------

class command_mget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mget_reply) */ {
 public:
  command_mget_reply();
  virtual ~command_mget_reply();

  command_mget_reply(const command_mget_reply& from);

  inline command_mget_reply& operator=(const command_mget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mget_reply(command_mget_reply&& from) noexcept
    : command_mget_reply() {
    *this = ::std::move(from);
  }

  inline command_mget_reply& operator=(command_mget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mget_reply* internal_default_instance() {
    return reinterpret_cast<const command_mget_reply*>(
               &_command_mget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(command_mget_reply* other);
  friend void swap(command_mget_reply& a, command_mget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mget_reply& from);
  void MergeFrom(const command_mget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mget_replyImpl();
};
// -------------------------------------------------------------------

class command_hget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hget) */ {
 public:
  command_hget();
  virtual ~command_hget();

  command_hget(const command_hget& from);

  inline command_hget& operator=(const command_hget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hget(command_hget&& from) noexcept
    : command_hget() {
    *this = ::std::move(from);
  }

  inline command_hget& operator=(command_hget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hget* internal_default_instance() {
    return reinterpret_cast<const command_hget*>(
               &_command_hget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(command_hget* other);
  friend void swap(command_hget& a, command_hget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hget& from);
  void MergeFrom(const command_hget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:client.command_hget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hgetImpl();
};
// -------------------------------------------------------------------

class command_hget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hget_reply) */ {
 public:
  command_hget_reply();
  virtual ~command_hget_reply();

  command_hget_reply(const command_hget_reply& from);

  inline command_hget_reply& operator=(const command_hget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hget_reply(command_hget_reply&& from) noexcept
    : command_hget_reply() {
    *this = ::std::move(from);
  }

  inline command_hget_reply& operator=(command_hget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hget_reply* internal_default_instance() {
    return reinterpret_cast<const command_hget_reply*>(
               &_command_hget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(command_hget_reply* other);
  friend void swap(command_hget_reply& a, command_hget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hget_reply& from);
  void MergeFrom(const command_hget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_hget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hget_replyImpl();
};
// -------------------------------------------------------------------

class command_hmget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmget) */ {
 public:
  command_hmget();
  virtual ~command_hmget();

  command_hmget(const command_hmget& from);

  inline command_hmget& operator=(const command_hmget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmget(command_hmget&& from) noexcept
    : command_hmget() {
    *this = ::std::move(from);
  }

  inline command_hmget& operator=(command_hmget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmget* internal_default_instance() {
    return reinterpret_cast<const command_hmget*>(
               &_command_hmget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(command_hmget* other);
  friend void swap(command_hmget& a, command_hmget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmget& from);
  void MergeFrom(const command_hmget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmgetImpl();
};
// -------------------------------------------------------------------

class command_hmget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmget_reply) */ {
 public:
  command_hmget_reply();
  virtual ~command_hmget_reply();

  command_hmget_reply(const command_hmget_reply& from);

  inline command_hmget_reply& operator=(const command_hmget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmget_reply(command_hmget_reply&& from) noexcept
    : command_hmget_reply() {
    *this = ::std::move(from);
  }

  inline command_hmget_reply& operator=(command_hmget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmget_reply* internal_default_instance() {
    return reinterpret_cast<const command_hmget_reply*>(
               &_command_hmget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(command_hmget_reply* other);
  friend void swap(command_hmget_reply& a, command_hmget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmget_reply& from);
  void MergeFrom(const command_hmget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_hmget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmget_replyImpl();
};
// -------------------------------------------------------------------

class command_mhmget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmget) */ {
 public:
  command_mhmget();
  virtual ~command_mhmget();

  command_mhmget(const command_mhmget& from);

  inline command_mhmget& operator=(const command_mhmget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmget(command_mhmget&& from) noexcept
    : command_mhmget() {
    *this = ::std::move(from);
  }

  inline command_mhmget& operator=(command_mhmget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmget* internal_default_instance() {
    return reinterpret_cast<const command_mhmget*>(
               &_command_mhmget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(command_mhmget* other);
  friend void swap(command_mhmget& a, command_mhmget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmget& from);
  void MergeFrom(const command_mhmget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:client.command_mhmget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmgetImpl();
};
// -------------------------------------------------------------------

class command_mhmget_reply_DataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mhmget_reply_DataEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mhmget_reply_DataEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mhmget_reply_DataEntry_DoNotUse();
  command_mhmget_reply_DataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mhmget_reply_DataEntry_DoNotUse& other);
  static const command_mhmget_reply_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mhmget_reply_DataEntry_DoNotUse*>(&_command_mhmget_reply_DataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mhmget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmget_reply) */ {
 public:
  command_mhmget_reply();
  virtual ~command_mhmget_reply();

  command_mhmget_reply(const command_mhmget_reply& from);

  inline command_mhmget_reply& operator=(const command_mhmget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmget_reply(command_mhmget_reply&& from) noexcept
    : command_mhmget_reply() {
    *this = ::std::move(from);
  }

  inline command_mhmget_reply& operator=(command_mhmget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmget_reply* internal_default_instance() {
    return reinterpret_cast<const command_mhmget_reply*>(
               &_command_mhmget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(command_mhmget_reply* other);
  friend void swap(command_mhmget_reply& a, command_mhmget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmget_reply& from);
  void MergeFrom(const command_mhmget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .client.values_type> data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::client::values_type >&
      data() const;
  ::google::protobuf::Map< ::std::string, ::client::values_type >*
      mutable_data();

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mhmget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_mhmget_reply_DataEntry_DoNotUse,
      ::std::string, ::client::values_type,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmget_replyImpl();
};
// -------------------------------------------------------------------

class command_del : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_del) */ {
 public:
  command_del();
  virtual ~command_del();

  command_del(const command_del& from);

  inline command_del& operator=(const command_del& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_del(command_del&& from) noexcept
    : command_del() {
    *this = ::std::move(from);
  }

  inline command_del& operator=(command_del&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_del& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_del* internal_default_instance() {
    return reinterpret_cast<const command_del*>(
               &_command_del_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(command_del* other);
  friend void swap(command_del& a, command_del& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_del* New() const PROTOBUF_FINAL { return New(NULL); }

  command_del* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_del& from);
  void MergeFrom(const command_del& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_del* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_del)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_delImpl();
};
// -------------------------------------------------------------------

class command_mdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mdel) */ {
 public:
  command_mdel();
  virtual ~command_mdel();

  command_mdel(const command_mdel& from);

  inline command_mdel& operator=(const command_mdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mdel(command_mdel&& from) noexcept
    : command_mdel() {
    *this = ::std::move(from);
  }

  inline command_mdel& operator=(command_mdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mdel* internal_default_instance() {
    return reinterpret_cast<const command_mdel*>(
               &_command_mdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(command_mdel* other);
  friend void swap(command_mdel& a, command_mdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mdel& from);
  void MergeFrom(const command_mdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:client.command_mdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mdelImpl();
};
// -------------------------------------------------------------------

class command_hdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hdel) */ {
 public:
  command_hdel();
  virtual ~command_hdel();

  command_hdel(const command_hdel& from);

  inline command_hdel& operator=(const command_hdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hdel(command_hdel&& from) noexcept
    : command_hdel() {
    *this = ::std::move(from);
  }

  inline command_hdel& operator=(command_hdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hdel* internal_default_instance() {
    return reinterpret_cast<const command_hdel*>(
               &_command_hdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(command_hdel* other);
  friend void swap(command_hdel& a, command_hdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hdel& from);
  void MergeFrom(const command_hdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:client.command_hdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hdelImpl();
};
// -------------------------------------------------------------------

class command_hmdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmdel) */ {
 public:
  command_hmdel();
  virtual ~command_hmdel();

  command_hmdel(const command_hmdel& from);

  inline command_hmdel& operator=(const command_hmdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmdel(command_hmdel&& from) noexcept
    : command_hmdel() {
    *this = ::std::move(from);
  }

  inline command_hmdel& operator=(command_hmdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmdel* internal_default_instance() {
    return reinterpret_cast<const command_hmdel*>(
               &_command_hmdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(command_hmdel* other);
  friend void swap(command_hmdel& a, command_hmdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmdel& from);
  void MergeFrom(const command_hmdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmdelImpl();
};
// -------------------------------------------------------------------

class command_mhmdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmdel) */ {
 public:
  command_mhmdel();
  virtual ~command_mhmdel();

  command_mhmdel(const command_mhmdel& from);

  inline command_mhmdel& operator=(const command_mhmdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmdel(command_mhmdel&& from) noexcept
    : command_mhmdel() {
    *this = ::std::move(from);
  }

  inline command_mhmdel& operator=(command_mhmdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmdel* internal_default_instance() {
    return reinterpret_cast<const command_mhmdel*>(
               &_command_mhmdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(command_mhmdel* other);
  friend void swap(command_mhmdel& a, command_mhmdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmdel& from);
  void MergeFrom(const command_mhmdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:client.command_mhmdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmdelImpl();
};
// -------------------------------------------------------------------

class command_incr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_incr) */ {
 public:
  command_incr();
  virtual ~command_incr();

  command_incr(const command_incr& from);

  inline command_incr& operator=(const command_incr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_incr(command_incr&& from) noexcept
    : command_incr() {
    *this = ::std::move(from);
  }

  inline command_incr& operator=(command_incr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_incr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_incr* internal_default_instance() {
    return reinterpret_cast<const command_incr*>(
               &_command_incr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(command_incr* other);
  friend void swap(command_incr& a, command_incr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_incr* New() const PROTOBUF_FINAL { return New(NULL); }

  command_incr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_incr& from);
  void MergeFrom(const command_incr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_incr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .data.VALUE value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_incr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_incrImpl();
};
// -------------------------------------------------------------------

class command_mincr_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mincr_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mincr_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mincr_KvsEntry_DoNotUse();
  command_mincr_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mincr_KvsEntry_DoNotUse& other);
  static const command_mincr_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mincr_KvsEntry_DoNotUse*>(&_command_mincr_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mincr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mincr) */ {
 public:
  command_mincr();
  virtual ~command_mincr();

  command_mincr(const command_mincr& from);

  inline command_mincr& operator=(const command_mincr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mincr(command_mincr&& from) noexcept
    : command_mincr() {
    *this = ::std::move(from);
  }

  inline command_mincr& operator=(command_mincr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mincr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mincr* internal_default_instance() {
    return reinterpret_cast<const command_mincr*>(
               &_command_mincr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(command_mincr* other);
  friend void swap(command_mincr& a, command_mincr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mincr* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mincr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mincr& from);
  void MergeFrom(const command_mincr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mincr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> kvs = 1;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:client.command_mincr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_mincr_KvsEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mincrImpl();
};
// -------------------------------------------------------------------

class command_hincr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hincr) */ {
 public:
  command_hincr();
  virtual ~command_hincr();

  command_hincr(const command_hincr& from);

  inline command_hincr& operator=(const command_hincr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hincr(command_hincr&& from) noexcept
    : command_hincr() {
    *this = ::std::move(from);
  }

  inline command_hincr& operator=(command_hincr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hincr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hincr* internal_default_instance() {
    return reinterpret_cast<const command_hincr*>(
               &_command_hincr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(command_hincr* other);
  friend void swap(command_hincr& a, command_hincr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hincr* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hincr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hincr& from);
  void MergeFrom(const command_hincr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hincr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // .data.VALUE value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_hincr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hincrImpl();
};
// -------------------------------------------------------------------

class command_hmincr_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_hmincr_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_hmincr_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_hmincr_KvsEntry_DoNotUse();
  command_hmincr_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_hmincr_KvsEntry_DoNotUse& other);
  static const command_hmincr_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_hmincr_KvsEntry_DoNotUse*>(&_command_hmincr_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_hmincr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmincr) */ {
 public:
  command_hmincr();
  virtual ~command_hmincr();

  command_hmincr(const command_hmincr& from);

  inline command_hmincr& operator=(const command_hmincr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmincr(command_hmincr&& from) noexcept
    : command_hmincr() {
    *this = ::std::move(from);
  }

  inline command_hmincr& operator=(command_hmincr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmincr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmincr* internal_default_instance() {
    return reinterpret_cast<const command_hmincr*>(
               &_command_hmincr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(command_hmincr* other);
  friend void swap(command_hmincr& a, command_hmincr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmincr* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmincr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmincr& from);
  void MergeFrom(const command_hmincr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmincr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_kvs();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmincr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_hmincr_KvsEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmincrImpl();
};
// -------------------------------------------------------------------

class command_mhmincr_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mhmincr_KvsEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mhmincr_KvsEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mhmincr_KvsEntry_DoNotUse();
  command_mhmincr_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mhmincr_KvsEntry_DoNotUse& other);
  static const command_mhmincr_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mhmincr_KvsEntry_DoNotUse*>(&_command_mhmincr_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mhmincr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmincr) */ {
 public:
  command_mhmincr();
  virtual ~command_mhmincr();

  command_mhmincr(const command_mhmincr& from);

  inline command_mhmincr& operator=(const command_mhmincr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmincr(command_mhmincr&& from) noexcept
    : command_mhmincr() {
    *this = ::std::move(from);
  }

  inline command_mhmincr& operator=(command_mhmincr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmincr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmincr* internal_default_instance() {
    return reinterpret_cast<const command_mhmincr*>(
               &_command_mhmincr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(command_mhmincr* other);
  friend void swap(command_mhmincr& a, command_mhmincr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmincr* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmincr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmincr& from);
  void MergeFrom(const command_mhmincr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmincr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // map<string, .client.values_type> kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::client::values_type >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::client::values_type >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:client.command_mhmincr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::MapField<
      command_mhmincr_KvsEntry_DoNotUse,
      ::std::string, ::client::values_type,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmincrImpl();
};
// -------------------------------------------------------------------

class command_lpush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_lpush) */ {
 public:
  command_lpush();
  virtual ~command_lpush();

  command_lpush(const command_lpush& from);

  inline command_lpush& operator=(const command_lpush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_lpush(command_lpush&& from) noexcept
    : command_lpush() {
    *this = ::std::move(from);
  }

  inline command_lpush& operator=(command_lpush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_lpush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_lpush* internal_default_instance() {
    return reinterpret_cast<const command_lpush*>(
               &_command_lpush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(command_lpush* other);
  friend void swap(command_lpush& a, command_lpush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_lpush* New() const PROTOBUF_FINAL { return New(NULL); }

  command_lpush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_lpush& from);
  void MergeFrom(const command_lpush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_lpush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .data.VALUE value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // bool head = 3;
  void clear_head();
  static const int kHeadFieldNumber = 3;
  bool head() const;
  void set_head(bool value);

  // @@protoc_insertion_point(class_scope:client.command_lpush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::data::VALUE* value_;
  bool head_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_lpushImpl();
};
// -------------------------------------------------------------------

class command_mlpush_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mlpush_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mlpush_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mlpush_KvsEntry_DoNotUse();
  command_mlpush_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mlpush_KvsEntry_DoNotUse& other);
  static const command_mlpush_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mlpush_KvsEntry_DoNotUse*>(&_command_mlpush_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mlpush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mlpush) */ {
 public:
  command_mlpush();
  virtual ~command_mlpush();

  command_mlpush(const command_mlpush& from);

  inline command_mlpush& operator=(const command_mlpush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mlpush(command_mlpush&& from) noexcept
    : command_mlpush() {
    *this = ::std::move(from);
  }

  inline command_mlpush& operator=(command_mlpush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mlpush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mlpush* internal_default_instance() {
    return reinterpret_cast<const command_mlpush*>(
               &_command_mlpush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(command_mlpush* other);
  friend void swap(command_mlpush& a, command_mlpush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mlpush* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mlpush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mlpush& from);
  void MergeFrom(const command_mlpush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mlpush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> kvs = 1;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_kvs();

  // bool head = 2;
  void clear_head();
  static const int kHeadFieldNumber = 2;
  bool head() const;
  void set_head(bool value);

  // @@protoc_insertion_point(class_scope:client.command_mlpush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_mlpush_KvsEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  bool head_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mlpushImpl();
};
// -------------------------------------------------------------------

class command_hlpush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hlpush) */ {
 public:
  command_hlpush();
  virtual ~command_hlpush();

  command_hlpush(const command_hlpush& from);

  inline command_hlpush& operator=(const command_hlpush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hlpush(command_hlpush&& from) noexcept
    : command_hlpush() {
    *this = ::std::move(from);
  }

  inline command_hlpush& operator=(command_hlpush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hlpush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hlpush* internal_default_instance() {
    return reinterpret_cast<const command_hlpush*>(
               &_command_hlpush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(command_hlpush* other);
  friend void swap(command_hlpush& a, command_hlpush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hlpush* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hlpush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hlpush& from);
  void MergeFrom(const command_hlpush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hlpush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // .data.VALUE value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_hlpush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hlpushImpl();
};
// -------------------------------------------------------------------

class command_hmlpush_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_hmlpush_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_hmlpush_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_hmlpush_KvsEntry_DoNotUse();
  command_hmlpush_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_hmlpush_KvsEntry_DoNotUse& other);
  static const command_hmlpush_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_hmlpush_KvsEntry_DoNotUse*>(&_command_hmlpush_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_hmlpush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmlpush) */ {
 public:
  command_hmlpush();
  virtual ~command_hmlpush();

  command_hmlpush(const command_hmlpush& from);

  inline command_hmlpush& operator=(const command_hmlpush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmlpush(command_hmlpush&& from) noexcept
    : command_hmlpush() {
    *this = ::std::move(from);
  }

  inline command_hmlpush& operator=(command_hmlpush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmlpush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmlpush* internal_default_instance() {
    return reinterpret_cast<const command_hmlpush*>(
               &_command_hmlpush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(command_hmlpush* other);
  friend void swap(command_hmlpush& a, command_hmlpush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmlpush* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmlpush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmlpush& from);
  void MergeFrom(const command_hmlpush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmlpush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_kvs();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmlpush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_hmlpush_KvsEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmlpushImpl();
};
// -------------------------------------------------------------------

class command_mhmlpush_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mhmlpush_KvsEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mhmlpush_KvsEntry_DoNotUse, 
    ::std::string, ::client::values_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mhmlpush_KvsEntry_DoNotUse();
  command_mhmlpush_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mhmlpush_KvsEntry_DoNotUse& other);
  static const command_mhmlpush_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mhmlpush_KvsEntry_DoNotUse*>(&_command_mhmlpush_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mhmlpush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmlpush) */ {
 public:
  command_mhmlpush();
  virtual ~command_mhmlpush();

  command_mhmlpush(const command_mhmlpush& from);

  inline command_mhmlpush& operator=(const command_mhmlpush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmlpush(command_mhmlpush&& from) noexcept
    : command_mhmlpush() {
    *this = ::std::move(from);
  }

  inline command_mhmlpush& operator=(command_mhmlpush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmlpush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmlpush* internal_default_instance() {
    return reinterpret_cast<const command_mhmlpush*>(
               &_command_mhmlpush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(command_mhmlpush* other);
  friend void swap(command_mhmlpush& a, command_mhmlpush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmlpush* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmlpush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmlpush& from);
  void MergeFrom(const command_mhmlpush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmlpush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // map<string, .client.values_type> kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::client::values_type >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::client::values_type >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:client.command_mhmlpush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::MapField<
      command_mhmlpush_KvsEntry_DoNotUse,
      ::std::string, ::client::values_type,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmlpushImpl();
};
// -------------------------------------------------------------------

class command_lrange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_lrange) */ {
 public:
  command_lrange();
  virtual ~command_lrange();

  command_lrange(const command_lrange& from);

  inline command_lrange& operator=(const command_lrange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_lrange(command_lrange&& from) noexcept
    : command_lrange() {
    *this = ::std::move(from);
  }

  inline command_lrange& operator=(command_lrange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_lrange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_lrange* internal_default_instance() {
    return reinterpret_cast<const command_lrange*>(
               &_command_lrange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(command_lrange* other);
  friend void swap(command_lrange& a, command_lrange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_lrange* New() const PROTOBUF_FINAL { return New(NULL); }

  command_lrange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_lrange& from);
  void MergeFrom(const command_lrange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_lrange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // int32 start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 3;
  void clear_stop();
  static const int kStopFieldNumber = 3;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_lrange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_lrangeImpl();
};
// -------------------------------------------------------------------

class command_lrange_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_lrange_reply) */ {
 public:
  command_lrange_reply();
  virtual ~command_lrange_reply();

  command_lrange_reply(const command_lrange_reply& from);

  inline command_lrange_reply& operator=(const command_lrange_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_lrange_reply(command_lrange_reply&& from) noexcept
    : command_lrange_reply() {
    *this = ::std::move(from);
  }

  inline command_lrange_reply& operator=(command_lrange_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_lrange_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_lrange_reply* internal_default_instance() {
    return reinterpret_cast<const command_lrange_reply*>(
               &_command_lrange_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(command_lrange_reply* other);
  friend void swap(command_lrange_reply& a, command_lrange_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_lrange_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_lrange_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_lrange_reply& from);
  void MergeFrom(const command_lrange_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_lrange_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_lrange_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_lrange_replyImpl();
};
// -------------------------------------------------------------------

class command_mlrange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mlrange) */ {
 public:
  command_mlrange();
  virtual ~command_mlrange();

  command_mlrange(const command_mlrange& from);

  inline command_mlrange& operator=(const command_mlrange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mlrange(command_mlrange&& from) noexcept
    : command_mlrange() {
    *this = ::std::move(from);
  }

  inline command_mlrange& operator=(command_mlrange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mlrange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mlrange* internal_default_instance() {
    return reinterpret_cast<const command_mlrange*>(
               &_command_mlrange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(command_mlrange* other);
  friend void swap(command_mlrange& a, command_mlrange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mlrange* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mlrange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mlrange& from);
  void MergeFrom(const command_mlrange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mlrange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // int32 start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 3;
  void clear_stop();
  static const int kStopFieldNumber = 3;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_mlrange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mlrangeImpl();
};
// -------------------------------------------------------------------

class command_mlrange_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mlrange_reply) */ {
 public:
  command_mlrange_reply();
  virtual ~command_mlrange_reply();

  command_mlrange_reply(const command_mlrange_reply& from);

  inline command_mlrange_reply& operator=(const command_mlrange_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mlrange_reply(command_mlrange_reply&& from) noexcept
    : command_mlrange_reply() {
    *this = ::std::move(from);
  }

  inline command_mlrange_reply& operator=(command_mlrange_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mlrange_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mlrange_reply* internal_default_instance() {
    return reinterpret_cast<const command_mlrange_reply*>(
               &_command_mlrange_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(command_mlrange_reply* other);
  friend void swap(command_mlrange_reply& a, command_mlrange_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mlrange_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mlrange_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mlrange_reply& from);
  void MergeFrom(const command_mlrange_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mlrange_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mlrange_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mlrange_replyImpl();
};
// -------------------------------------------------------------------

class command_hlrange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hlrange) */ {
 public:
  command_hlrange();
  virtual ~command_hlrange();

  command_hlrange(const command_hlrange& from);

  inline command_hlrange& operator=(const command_hlrange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hlrange(command_hlrange&& from) noexcept
    : command_hlrange() {
    *this = ::std::move(from);
  }

  inline command_hlrange& operator=(command_hlrange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hlrange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hlrange* internal_default_instance() {
    return reinterpret_cast<const command_hlrange*>(
               &_command_hlrange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(command_hlrange* other);
  friend void swap(command_hlrange& a, command_hlrange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hlrange* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hlrange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hlrange& from);
  void MergeFrom(const command_hlrange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hlrange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 4;
  void clear_stop();
  static const int kStopFieldNumber = 4;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_hlrange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hlrangeImpl();
};
// -------------------------------------------------------------------

class command_hlrange_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hlrange_reply) */ {
 public:
  command_hlrange_reply();
  virtual ~command_hlrange_reply();

  command_hlrange_reply(const command_hlrange_reply& from);

  inline command_hlrange_reply& operator=(const command_hlrange_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hlrange_reply(command_hlrange_reply&& from) noexcept
    : command_hlrange_reply() {
    *this = ::std::move(from);
  }

  inline command_hlrange_reply& operator=(command_hlrange_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hlrange_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hlrange_reply* internal_default_instance() {
    return reinterpret_cast<const command_hlrange_reply*>(
               &_command_hlrange_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(command_hlrange_reply* other);
  friend void swap(command_hlrange_reply& a, command_hlrange_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hlrange_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hlrange_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hlrange_reply& from);
  void MergeFrom(const command_hlrange_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hlrange_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_hlrange_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hlrange_replyImpl();
};
// -------------------------------------------------------------------

class command_hmlrange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmlrange) */ {
 public:
  command_hmlrange();
  virtual ~command_hmlrange();

  command_hmlrange(const command_hmlrange& from);

  inline command_hmlrange& operator=(const command_hmlrange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmlrange(command_hmlrange&& from) noexcept
    : command_hmlrange() {
    *this = ::std::move(from);
  }

  inline command_hmlrange& operator=(command_hmlrange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmlrange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmlrange* internal_default_instance() {
    return reinterpret_cast<const command_hmlrange*>(
               &_command_hmlrange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(command_hmlrange* other);
  friend void swap(command_hmlrange& a, command_hmlrange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmlrange* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmlrange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmlrange& from);
  void MergeFrom(const command_hmlrange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmlrange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 4;
  void clear_stop();
  static const int kStopFieldNumber = 4;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_hmlrange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmlrangeImpl();
};
// -------------------------------------------------------------------

class command_hmlrange_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmlrange_reply) */ {
 public:
  command_hmlrange_reply();
  virtual ~command_hmlrange_reply();

  command_hmlrange_reply(const command_hmlrange_reply& from);

  inline command_hmlrange_reply& operator=(const command_hmlrange_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmlrange_reply(command_hmlrange_reply&& from) noexcept
    : command_hmlrange_reply() {
    *this = ::std::move(from);
  }

  inline command_hmlrange_reply& operator=(command_hmlrange_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmlrange_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmlrange_reply* internal_default_instance() {
    return reinterpret_cast<const command_hmlrange_reply*>(
               &_command_hmlrange_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(command_hmlrange_reply* other);
  friend void swap(command_hmlrange_reply& a, command_hmlrange_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmlrange_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmlrange_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmlrange_reply& from);
  void MergeFrom(const command_hmlrange_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmlrange_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_hmlrange_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmlrange_replyImpl();
};
// -------------------------------------------------------------------

class command_mhmlrange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmlrange) */ {
 public:
  command_mhmlrange();
  virtual ~command_mhmlrange();

  command_mhmlrange(const command_mhmlrange& from);

  inline command_mhmlrange& operator=(const command_mhmlrange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmlrange(command_mhmlrange&& from) noexcept
    : command_mhmlrange() {
    *this = ::std::move(from);
  }

  inline command_mhmlrange& operator=(command_mhmlrange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmlrange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmlrange* internal_default_instance() {
    return reinterpret_cast<const command_mhmlrange*>(
               &_command_mhmlrange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(command_mhmlrange* other);
  friend void swap(command_mhmlrange& a, command_mhmlrange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmlrange* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmlrange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmlrange& from);
  void MergeFrom(const command_mhmlrange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmlrange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:client.command_mhmlrange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmlrangeImpl();
};
// -------------------------------------------------------------------

class command_mhmlrange_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmlrange_reply) */ {
 public:
  command_mhmlrange_reply();
  virtual ~command_mhmlrange_reply();

  command_mhmlrange_reply(const command_mhmlrange_reply& from);

  inline command_mhmlrange_reply& operator=(const command_mhmlrange_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmlrange_reply(command_mhmlrange_reply&& from) noexcept
    : command_mhmlrange_reply() {
    *this = ::std::move(from);
  }

  inline command_mhmlrange_reply& operator=(command_mhmlrange_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmlrange_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmlrange_reply* internal_default_instance() {
    return reinterpret_cast<const command_mhmlrange_reply*>(
               &_command_mhmlrange_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(command_mhmlrange_reply* other);
  friend void swap(command_mhmlrange_reply& a, command_mhmlrange_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmlrange_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmlrange_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmlrange_reply& from);
  void MergeFrom(const command_mhmlrange_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmlrange_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.values_type data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::client::values_type& data(int index) const;
  ::client::values_type* mutable_data(int index);
  ::client::values_type* add_data();
  ::google::protobuf::RepeatedPtrField< ::client::values_type >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mhmlrange_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::client::values_type > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmlrange_replyImpl();
};
// -------------------------------------------------------------------

class command_lpop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_lpop) */ {
 public:
  command_lpop();
  virtual ~command_lpop();

  command_lpop(const command_lpop& from);

  inline command_lpop& operator=(const command_lpop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_lpop(command_lpop&& from) noexcept
    : command_lpop() {
    *this = ::std::move(from);
  }

  inline command_lpop& operator=(command_lpop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_lpop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_lpop* internal_default_instance() {
    return reinterpret_cast<const command_lpop*>(
               &_command_lpop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(command_lpop* other);
  friend void swap(command_lpop& a, command_lpop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_lpop* New() const PROTOBUF_FINAL { return New(NULL); }

  command_lpop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_lpop& from);
  void MergeFrom(const command_lpop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_lpop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bool head = 2;
  void clear_head();
  static const int kHeadFieldNumber = 2;
  bool head() const;
  void set_head(bool value);

  // @@protoc_insertion_point(class_scope:client.command_lpop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  bool head_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_lpopImpl();
};
// -------------------------------------------------------------------

class command_lpop_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_lpop_reply) */ {
 public:
  command_lpop_reply();
  virtual ~command_lpop_reply();

  command_lpop_reply(const command_lpop_reply& from);

  inline command_lpop_reply& operator=(const command_lpop_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_lpop_reply(command_lpop_reply&& from) noexcept
    : command_lpop_reply() {
    *this = ::std::move(from);
  }

  inline command_lpop_reply& operator=(command_lpop_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_lpop_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_lpop_reply* internal_default_instance() {
    return reinterpret_cast<const command_lpop_reply*>(
               &_command_lpop_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(command_lpop_reply* other);
  friend void swap(command_lpop_reply& a, command_lpop_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_lpop_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_lpop_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_lpop_reply& from);
  void MergeFrom(const command_lpop_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_lpop_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_lpop_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_lpop_replyImpl();
};
// -------------------------------------------------------------------

class command_mlpop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mlpop) */ {
 public:
  command_mlpop();
  virtual ~command_mlpop();

  command_mlpop(const command_mlpop& from);

  inline command_mlpop& operator=(const command_mlpop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mlpop(command_mlpop&& from) noexcept
    : command_mlpop() {
    *this = ::std::move(from);
  }

  inline command_mlpop& operator=(command_mlpop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mlpop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mlpop* internal_default_instance() {
    return reinterpret_cast<const command_mlpop*>(
               &_command_mlpop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(command_mlpop* other);
  friend void swap(command_mlpop& a, command_mlpop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mlpop* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mlpop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mlpop& from);
  void MergeFrom(const command_mlpop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mlpop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // bool head = 2;
  void clear_head();
  static const int kHeadFieldNumber = 2;
  bool head() const;
  void set_head(bool value);

  // @@protoc_insertion_point(class_scope:client.command_mlpop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool head_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mlpopImpl();
};
// -------------------------------------------------------------------

class command_mlpop_repy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mlpop_repy) */ {
 public:
  command_mlpop_repy();
  virtual ~command_mlpop_repy();

  command_mlpop_repy(const command_mlpop_repy& from);

  inline command_mlpop_repy& operator=(const command_mlpop_repy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mlpop_repy(command_mlpop_repy&& from) noexcept
    : command_mlpop_repy() {
    *this = ::std::move(from);
  }

  inline command_mlpop_repy& operator=(command_mlpop_repy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mlpop_repy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mlpop_repy* internal_default_instance() {
    return reinterpret_cast<const command_mlpop_repy*>(
               &_command_mlpop_repy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(command_mlpop_repy* other);
  friend void swap(command_mlpop_repy& a, command_mlpop_repy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mlpop_repy* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mlpop_repy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mlpop_repy& from);
  void MergeFrom(const command_mlpop_repy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mlpop_repy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mlpop_repy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mlpop_repyImpl();
};
// -------------------------------------------------------------------

class command_hlpop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hlpop) */ {
 public:
  command_hlpop();
  virtual ~command_hlpop();

  command_hlpop(const command_hlpop& from);

  inline command_hlpop& operator=(const command_hlpop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hlpop(command_hlpop&& from) noexcept
    : command_hlpop() {
    *this = ::std::move(from);
  }

  inline command_hlpop& operator=(command_hlpop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hlpop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hlpop* internal_default_instance() {
    return reinterpret_cast<const command_hlpop*>(
               &_command_hlpop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(command_hlpop* other);
  friend void swap(command_hlpop& a, command_hlpop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hlpop* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hlpop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hlpop& from);
  void MergeFrom(const command_hlpop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hlpop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:client.command_hlpop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hlpopImpl();
};
// -------------------------------------------------------------------

class command_hlpop_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hlpop_reply) */ {
 public:
  command_hlpop_reply();
  virtual ~command_hlpop_reply();

  command_hlpop_reply(const command_hlpop_reply& from);

  inline command_hlpop_reply& operator=(const command_hlpop_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hlpop_reply(command_hlpop_reply&& from) noexcept
    : command_hlpop_reply() {
    *this = ::std::move(from);
  }

  inline command_hlpop_reply& operator=(command_hlpop_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hlpop_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hlpop_reply* internal_default_instance() {
    return reinterpret_cast<const command_hlpop_reply*>(
               &_command_hlpop_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(command_hlpop_reply* other);
  friend void swap(command_hlpop_reply& a, command_hlpop_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hlpop_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hlpop_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hlpop_reply& from);
  void MergeFrom(const command_hlpop_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hlpop_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_hlpop_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hlpop_replyImpl();
};
// -------------------------------------------------------------------

class command_hmlpop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmlpop) */ {
 public:
  command_hmlpop();
  virtual ~command_hmlpop();

  command_hmlpop(const command_hmlpop& from);

  inline command_hmlpop& operator=(const command_hmlpop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmlpop(command_hmlpop&& from) noexcept
    : command_hmlpop() {
    *this = ::std::move(from);
  }

  inline command_hmlpop& operator=(command_hmlpop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmlpop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmlpop* internal_default_instance() {
    return reinterpret_cast<const command_hmlpop*>(
               &_command_hmlpop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(command_hmlpop* other);
  friend void swap(command_hmlpop& a, command_hmlpop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmlpop* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmlpop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmlpop& from);
  void MergeFrom(const command_hmlpop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmlpop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmlpop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmlpopImpl();
};
// -------------------------------------------------------------------

class command_hmlpop_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmlpop_reply) */ {
 public:
  command_hmlpop_reply();
  virtual ~command_hmlpop_reply();

  command_hmlpop_reply(const command_hmlpop_reply& from);

  inline command_hmlpop_reply& operator=(const command_hmlpop_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmlpop_reply(command_hmlpop_reply&& from) noexcept
    : command_hmlpop_reply() {
    *this = ::std::move(from);
  }

  inline command_hmlpop_reply& operator=(command_hmlpop_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmlpop_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmlpop_reply* internal_default_instance() {
    return reinterpret_cast<const command_hmlpop_reply*>(
               &_command_hmlpop_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(command_hmlpop_reply* other);
  friend void swap(command_hmlpop_reply& a, command_hmlpop_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmlpop_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmlpop_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmlpop_reply& from);
  void MergeFrom(const command_hmlpop_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmlpop_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_hmlpop_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmlpop_replyImpl();
};
// -------------------------------------------------------------------

class command_mhmlpop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmlpop) */ {
 public:
  command_mhmlpop();
  virtual ~command_mhmlpop();

  command_mhmlpop(const command_mhmlpop& from);

  inline command_mhmlpop& operator=(const command_mhmlpop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmlpop(command_mhmlpop&& from) noexcept
    : command_mhmlpop() {
    *this = ::std::move(from);
  }

  inline command_mhmlpop& operator=(command_mhmlpop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmlpop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmlpop* internal_default_instance() {
    return reinterpret_cast<const command_mhmlpop*>(
               &_command_mhmlpop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(command_mhmlpop* other);
  friend void swap(command_mhmlpop& a, command_mhmlpop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmlpop* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmlpop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmlpop& from);
  void MergeFrom(const command_mhmlpop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmlpop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:client.command_mhmlpop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmlpopImpl();
};
// -------------------------------------------------------------------

class command_mhmlpop_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmlpop_reply) */ {
 public:
  command_mhmlpop_reply();
  virtual ~command_mhmlpop_reply();

  command_mhmlpop_reply(const command_mhmlpop_reply& from);

  inline command_mhmlpop_reply& operator=(const command_mhmlpop_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmlpop_reply(command_mhmlpop_reply&& from) noexcept
    : command_mhmlpop_reply() {
    *this = ::std::move(from);
  }

  inline command_mhmlpop_reply& operator=(command_mhmlpop_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmlpop_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmlpop_reply* internal_default_instance() {
    return reinterpret_cast<const command_mhmlpop_reply*>(
               &_command_mhmlpop_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(command_mhmlpop_reply* other);
  friend void swap(command_mhmlpop_reply& a, command_mhmlpop_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmlpop_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmlpop_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmlpop_reply& from);
  void MergeFrom(const command_mhmlpop_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmlpop_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.values_type data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::client::values_type& data(int index) const;
  ::client::values_type* mutable_data(int index);
  ::client::values_type* add_data();
  ::google::protobuf::RepeatedPtrField< ::client::values_type >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mhmlpop_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::client::values_type > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmlpop_replyImpl();
};
// -------------------------------------------------------------------

class command_ltrim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_ltrim) */ {
 public:
  command_ltrim();
  virtual ~command_ltrim();

  command_ltrim(const command_ltrim& from);

  inline command_ltrim& operator=(const command_ltrim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_ltrim(command_ltrim&& from) noexcept
    : command_ltrim() {
    *this = ::std::move(from);
  }

  inline command_ltrim& operator=(command_ltrim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_ltrim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_ltrim* internal_default_instance() {
    return reinterpret_cast<const command_ltrim*>(
               &_command_ltrim_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(command_ltrim* other);
  friend void swap(command_ltrim& a, command_ltrim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_ltrim* New() const PROTOBUF_FINAL { return New(NULL); }

  command_ltrim* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_ltrim& from);
  void MergeFrom(const command_ltrim& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_ltrim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // int32 start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 3;
  void clear_stop();
  static const int kStopFieldNumber = 3;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_ltrim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_ltrimImpl();
};
// -------------------------------------------------------------------

class command_mltrim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mltrim) */ {
 public:
  command_mltrim();
  virtual ~command_mltrim();

  command_mltrim(const command_mltrim& from);

  inline command_mltrim& operator=(const command_mltrim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mltrim(command_mltrim&& from) noexcept
    : command_mltrim() {
    *this = ::std::move(from);
  }

  inline command_mltrim& operator=(command_mltrim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mltrim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mltrim* internal_default_instance() {
    return reinterpret_cast<const command_mltrim*>(
               &_command_mltrim_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(command_mltrim* other);
  friend void swap(command_mltrim& a, command_mltrim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mltrim* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mltrim* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mltrim& from);
  void MergeFrom(const command_mltrim& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mltrim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // int32 start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 3;
  void clear_stop();
  static const int kStopFieldNumber = 3;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_mltrim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mltrimImpl();
};
// -------------------------------------------------------------------

class command_hltrim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hltrim) */ {
 public:
  command_hltrim();
  virtual ~command_hltrim();

  command_hltrim(const command_hltrim& from);

  inline command_hltrim& operator=(const command_hltrim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hltrim(command_hltrim&& from) noexcept
    : command_hltrim() {
    *this = ::std::move(from);
  }

  inline command_hltrim& operator=(command_hltrim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hltrim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hltrim* internal_default_instance() {
    return reinterpret_cast<const command_hltrim*>(
               &_command_hltrim_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(command_hltrim* other);
  friend void swap(command_hltrim& a, command_hltrim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hltrim* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hltrim* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hltrim& from);
  void MergeFrom(const command_hltrim& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hltrim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string filed = 2;
  void clear_filed();
  static const int kFiledFieldNumber = 2;
  const ::std::string& filed() const;
  void set_filed(const ::std::string& value);
  #if LANG_CXX11
  void set_filed(::std::string&& value);
  #endif
  void set_filed(const char* value);
  void set_filed(const char* value, size_t size);
  ::std::string* mutable_filed();
  ::std::string* release_filed();
  void set_allocated_filed(::std::string* filed);

  // int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 4;
  void clear_stop();
  static const int kStopFieldNumber = 4;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_hltrim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr filed_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hltrimImpl();
};
// -------------------------------------------------------------------

class command_hmltrim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmltrim) */ {
 public:
  command_hmltrim();
  virtual ~command_hmltrim();

  command_hmltrim(const command_hmltrim& from);

  inline command_hmltrim& operator=(const command_hmltrim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmltrim(command_hmltrim&& from) noexcept
    : command_hmltrim() {
    *this = ::std::move(from);
  }

  inline command_hmltrim& operator=(command_hmltrim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmltrim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmltrim* internal_default_instance() {
    return reinterpret_cast<const command_hmltrim*>(
               &_command_hmltrim_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(command_hmltrim* other);
  friend void swap(command_hmltrim& a, command_hmltrim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmltrim* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmltrim* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmltrim& from);
  void MergeFrom(const command_hmltrim& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmltrim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fileds = 2;
  int fileds_size() const;
  void clear_fileds();
  static const int kFiledsFieldNumber = 2;
  const ::std::string& fileds(int index) const;
  ::std::string* mutable_fileds(int index);
  void set_fileds(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fileds(int index, ::std::string&& value);
  #endif
  void set_fileds(int index, const char* value);
  void set_fileds(int index, const char* value, size_t size);
  ::std::string* add_fileds();
  void add_fileds(const ::std::string& value);
  #if LANG_CXX11
  void add_fileds(::std::string&& value);
  #endif
  void add_fileds(const char* value);
  void add_fileds(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fileds() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fileds();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 4;
  void clear_stop();
  static const int kStopFieldNumber = 4;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_hmltrim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fileds_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmltrimImpl();
};
// -------------------------------------------------------------------

class command_mhmltrim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmltrim) */ {
 public:
  command_mhmltrim();
  virtual ~command_mhmltrim();

  command_mhmltrim(const command_mhmltrim& from);

  inline command_mhmltrim& operator=(const command_mhmltrim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmltrim(command_mhmltrim&& from) noexcept
    : command_mhmltrim() {
    *this = ::std::move(from);
  }

  inline command_mhmltrim& operator=(command_mhmltrim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmltrim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmltrim* internal_default_instance() {
    return reinterpret_cast<const command_mhmltrim*>(
               &_command_mhmltrim_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(command_mhmltrim* other);
  friend void swap(command_mhmltrim& a, command_mhmltrim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmltrim* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmltrim* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmltrim& from);
  void MergeFrom(const command_mhmltrim& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmltrim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fileds = 2;
  int fileds_size() const;
  void clear_fileds();
  static const int kFiledsFieldNumber = 2;
  const ::std::string& fileds(int index) const;
  ::std::string* mutable_fileds(int index);
  void set_fileds(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fileds(int index, ::std::string&& value);
  #endif
  void set_fileds(int index, const char* value);
  void set_fileds(int index, const char* value, size_t size);
  ::std::string* add_fileds();
  void add_fileds(const ::std::string& value);
  #if LANG_CXX11
  void add_fileds(::std::string&& value);
  #endif
  void add_fileds(const char* value);
  void add_fileds(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fileds() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fileds();

  // int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 stop = 4;
  void clear_stop();
  static const int kStopFieldNumber = 4;
  ::google::protobuf::int32 stop() const;
  void set_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.command_mhmltrim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fileds_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 stop_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmltrimImpl();
};
// -------------------------------------------------------------------

class command_llen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_llen) */ {
 public:
  command_llen();
  virtual ~command_llen();

  command_llen(const command_llen& from);

  inline command_llen& operator=(const command_llen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_llen(command_llen&& from) noexcept
    : command_llen() {
    *this = ::std::move(from);
  }

  inline command_llen& operator=(command_llen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_llen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_llen* internal_default_instance() {
    return reinterpret_cast<const command_llen*>(
               &_command_llen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(command_llen* other);
  friend void swap(command_llen& a, command_llen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_llen* New() const PROTOBUF_FINAL { return New(NULL); }

  command_llen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_llen& from);
  void MergeFrom(const command_llen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_llen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_llen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_llenImpl();
};
// -------------------------------------------------------------------

class command_llen_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_llen_reply) */ {
 public:
  command_llen_reply();
  virtual ~command_llen_reply();

  command_llen_reply(const command_llen_reply& from);

  inline command_llen_reply& operator=(const command_llen_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_llen_reply(command_llen_reply&& from) noexcept
    : command_llen_reply() {
    *this = ::std::move(from);
  }

  inline command_llen_reply& operator=(command_llen_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_llen_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_llen_reply* internal_default_instance() {
    return reinterpret_cast<const command_llen_reply*>(
               &_command_llen_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void Swap(command_llen_reply* other);
  friend void swap(command_llen_reply& a, command_llen_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_llen_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_llen_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_llen_reply& from);
  void MergeFrom(const command_llen_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_llen_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_llen_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_llen_replyImpl();
};
// -------------------------------------------------------------------

class command_mllen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mllen) */ {
 public:
  command_mllen();
  virtual ~command_mllen();

  command_mllen(const command_mllen& from);

  inline command_mllen& operator=(const command_mllen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mllen(command_mllen&& from) noexcept
    : command_mllen() {
    *this = ::std::move(from);
  }

  inline command_mllen& operator=(command_mllen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mllen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mllen* internal_default_instance() {
    return reinterpret_cast<const command_mllen*>(
               &_command_mllen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(command_mllen* other);
  friend void swap(command_mllen& a, command_mllen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mllen* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mllen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mllen& from);
  void MergeFrom(const command_mllen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mllen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:client.command_mllen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mllenImpl();
};
// -------------------------------------------------------------------

class command_mllen_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mllen_reply) */ {
 public:
  command_mllen_reply();
  virtual ~command_mllen_reply();

  command_mllen_reply(const command_mllen_reply& from);

  inline command_mllen_reply& operator=(const command_mllen_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mllen_reply(command_mllen_reply&& from) noexcept
    : command_mllen_reply() {
    *this = ::std::move(from);
  }

  inline command_mllen_reply& operator=(command_mllen_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mllen_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mllen_reply* internal_default_instance() {
    return reinterpret_cast<const command_mllen_reply*>(
               &_command_mllen_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(command_mllen_reply* other);
  friend void swap(command_mllen_reply& a, command_mllen_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mllen_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mllen_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mllen_reply& from);
  void MergeFrom(const command_mllen_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mllen_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mllen_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mllen_replyImpl();
};
// -------------------------------------------------------------------

class command_hllen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hllen) */ {
 public:
  command_hllen();
  virtual ~command_hllen();

  command_hllen(const command_hllen& from);

  inline command_hllen& operator=(const command_hllen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hllen(command_hllen&& from) noexcept
    : command_hllen() {
    *this = ::std::move(from);
  }

  inline command_hllen& operator=(command_hllen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hllen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hllen* internal_default_instance() {
    return reinterpret_cast<const command_hllen*>(
               &_command_hllen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void Swap(command_hllen* other);
  friend void swap(command_hllen& a, command_hllen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hllen* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hllen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hllen& from);
  void MergeFrom(const command_hllen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hllen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:client.command_hllen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hllenImpl();
};
// -------------------------------------------------------------------

class command_hllen_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hllen_reply) */ {
 public:
  command_hllen_reply();
  virtual ~command_hllen_reply();

  command_hllen_reply(const command_hllen_reply& from);

  inline command_hllen_reply& operator=(const command_hllen_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hllen_reply(command_hllen_reply&& from) noexcept
    : command_hllen_reply() {
    *this = ::std::move(from);
  }

  inline command_hllen_reply& operator=(command_hllen_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hllen_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hllen_reply* internal_default_instance() {
    return reinterpret_cast<const command_hllen_reply*>(
               &_command_hllen_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    73;

  void Swap(command_hllen_reply* other);
  friend void swap(command_hllen_reply& a, command_hllen_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hllen_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hllen_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hllen_reply& from);
  void MergeFrom(const command_hllen_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hllen_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_hllen_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hllen_replyImpl();
};
// -------------------------------------------------------------------

class command_hmllen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmllen) */ {
 public:
  command_hmllen();
  virtual ~command_hmllen();

  command_hmllen(const command_hmllen& from);

  inline command_hmllen& operator=(const command_hmllen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmllen(command_hmllen&& from) noexcept
    : command_hmllen() {
    *this = ::std::move(from);
  }

  inline command_hmllen& operator=(command_hmllen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmllen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmllen* internal_default_instance() {
    return reinterpret_cast<const command_hmllen*>(
               &_command_hmllen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void Swap(command_hmllen* other);
  friend void swap(command_hmllen& a, command_hmllen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmllen* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmllen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmllen& from);
  void MergeFrom(const command_hmllen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmllen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmllen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmllenImpl();
};
// -------------------------------------------------------------------

class command_hmllen_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmllen_reply) */ {
 public:
  command_hmllen_reply();
  virtual ~command_hmllen_reply();

  command_hmllen_reply(const command_hmllen_reply& from);

  inline command_hmllen_reply& operator=(const command_hmllen_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmllen_reply(command_hmllen_reply&& from) noexcept
    : command_hmllen_reply() {
    *this = ::std::move(from);
  }

  inline command_hmllen_reply& operator=(command_hmllen_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmllen_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmllen_reply* internal_default_instance() {
    return reinterpret_cast<const command_hmllen_reply*>(
               &_command_hmllen_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void Swap(command_hmllen_reply* other);
  friend void swap(command_hmllen_reply& a, command_hmllen_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmllen_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmllen_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmllen_reply& from);
  void MergeFrom(const command_hmllen_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmllen_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_hmllen_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmllen_replyImpl();
};
// -------------------------------------------------------------------

class command_mhmllen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmllen) */ {
 public:
  command_mhmllen();
  virtual ~command_mhmllen();

  command_mhmllen(const command_mhmllen& from);

  inline command_mhmllen& operator=(const command_mhmllen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmllen(command_mhmllen&& from) noexcept
    : command_mhmllen() {
    *this = ::std::move(from);
  }

  inline command_mhmllen& operator=(command_mhmllen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmllen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmllen* internal_default_instance() {
    return reinterpret_cast<const command_mhmllen*>(
               &_command_mhmllen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void Swap(command_mhmllen* other);
  friend void swap(command_mhmllen& a, command_mhmllen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmllen* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmllen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmllen& from);
  void MergeFrom(const command_mhmllen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmllen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:client.command_mhmllen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmllenImpl();
};
// -------------------------------------------------------------------

class command_mhmllen_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmllen_reply) */ {
 public:
  command_mhmllen_reply();
  virtual ~command_mhmllen_reply();

  command_mhmllen_reply(const command_mhmllen_reply& from);

  inline command_mhmllen_reply& operator=(const command_mhmllen_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmllen_reply(command_mhmllen_reply&& from) noexcept
    : command_mhmllen_reply() {
    *this = ::std::move(from);
  }

  inline command_mhmllen_reply& operator=(command_mhmllen_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmllen_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmllen_reply* internal_default_instance() {
    return reinterpret_cast<const command_mhmllen_reply*>(
               &_command_mhmllen_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    77;

  void Swap(command_mhmllen_reply* other);
  friend void swap(command_mhmllen_reply& a, command_mhmllen_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmllen_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmllen_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmllen_reply& from);
  void MergeFrom(const command_mhmllen_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmllen_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.values_type data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::client::values_type& data(int index) const;
  ::client::values_type* mutable_data(int index);
  ::client::values_type* add_data();
  ::google::protobuf::RepeatedPtrField< ::client::values_type >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mhmllen_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::client::values_type > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmllen_replyImpl();
};
// -------------------------------------------------------------------

class command_mapget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mapget) */ {
 public:
  command_mapget();
  virtual ~command_mapget();

  command_mapget(const command_mapget& from);

  inline command_mapget& operator=(const command_mapget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mapget(command_mapget&& from) noexcept
    : command_mapget() {
    *this = ::std::move(from);
  }

  inline command_mapget& operator=(command_mapget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mapget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mapget* internal_default_instance() {
    return reinterpret_cast<const command_mapget*>(
               &_command_mapget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    78;

  void Swap(command_mapget* other);
  friend void swap(command_mapget& a, command_mapget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mapget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mapget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mapget& from);
  void MergeFrom(const command_mapget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mapget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_mapget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mapgetImpl();
};
// -------------------------------------------------------------------

class command_mapget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mapget_reply) */ {
 public:
  command_mapget_reply();
  virtual ~command_mapget_reply();

  command_mapget_reply(const command_mapget_reply& from);

  inline command_mapget_reply& operator=(const command_mapget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mapget_reply(command_mapget_reply&& from) noexcept
    : command_mapget_reply() {
    *this = ::std::move(from);
  }

  inline command_mapget_reply& operator=(command_mapget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mapget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mapget_reply* internal_default_instance() {
    return reinterpret_cast<const command_mapget_reply*>(
               &_command_mapget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    79;

  void Swap(command_mapget_reply* other);
  friend void swap(command_mapget_reply& a, command_mapget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mapget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mapget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mapget_reply& from);
  void MergeFrom(const command_mapget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mapget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_mapget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mapget_replyImpl();
};
// -------------------------------------------------------------------

class command_mmapget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mmapget) */ {
 public:
  command_mmapget();
  virtual ~command_mmapget();

  command_mmapget(const command_mmapget& from);

  inline command_mmapget& operator=(const command_mmapget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mmapget(command_mmapget&& from) noexcept
    : command_mmapget() {
    *this = ::std::move(from);
  }

  inline command_mmapget& operator=(command_mmapget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mmapget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mmapget* internal_default_instance() {
    return reinterpret_cast<const command_mmapget*>(
               &_command_mmapget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    80;

  void Swap(command_mmapget* other);
  friend void swap(command_mmapget& a, command_mmapget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mmapget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mmapget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mmapget& from);
  void MergeFrom(const command_mmapget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mmapget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:client.command_mmapget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mmapgetImpl();
};
// -------------------------------------------------------------------

class command_mmapget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mmapget_reply) */ {
 public:
  command_mmapget_reply();
  virtual ~command_mmapget_reply();

  command_mmapget_reply(const command_mmapget_reply& from);

  inline command_mmapget_reply& operator=(const command_mmapget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mmapget_reply(command_mmapget_reply&& from) noexcept
    : command_mmapget_reply() {
    *this = ::std::move(from);
  }

  inline command_mmapget_reply& operator=(command_mmapget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mmapget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mmapget_reply* internal_default_instance() {
    return reinterpret_cast<const command_mmapget_reply*>(
               &_command_mmapget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    81;

  void Swap(command_mmapget_reply* other);
  friend void swap(command_mmapget_reply& a, command_mmapget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mmapget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mmapget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mmapget_reply& from);
  void MergeFrom(const command_mmapget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mmapget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mmapget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mmapget_replyImpl();
};
// -------------------------------------------------------------------

class command_hmapget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmapget) */ {
 public:
  command_hmapget();
  virtual ~command_hmapget();

  command_hmapget(const command_hmapget& from);

  inline command_hmapget& operator=(const command_hmapget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmapget(command_hmapget&& from) noexcept
    : command_hmapget() {
    *this = ::std::move(from);
  }

  inline command_hmapget& operator=(command_hmapget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmapget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmapget* internal_default_instance() {
    return reinterpret_cast<const command_hmapget*>(
               &_command_hmapget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    82;

  void Swap(command_hmapget* other);
  friend void swap(command_hmapget& a, command_hmapget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmapget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmapget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmapget& from);
  void MergeFrom(const command_hmapget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmapget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:client.command_hmapget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmapgetImpl();
};
// -------------------------------------------------------------------

class command_hmapget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmapget_reply) */ {
 public:
  command_hmapget_reply();
  virtual ~command_hmapget_reply();

  command_hmapget_reply(const command_hmapget_reply& from);

  inline command_hmapget_reply& operator=(const command_hmapget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmapget_reply(command_hmapget_reply&& from) noexcept
    : command_hmapget_reply() {
    *this = ::std::move(from);
  }

  inline command_hmapget_reply& operator=(command_hmapget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmapget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmapget_reply* internal_default_instance() {
    return reinterpret_cast<const command_hmapget_reply*>(
               &_command_hmapget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    83;

  void Swap(command_hmapget_reply* other);
  friend void swap(command_hmapget_reply& a, command_hmapget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmapget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmapget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmapget_reply& from);
  void MergeFrom(const command_hmapget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmapget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // .data.VALUE data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data() const;
  ::data::VALUE* release_data();
  ::data::VALUE* mutable_data();
  void set_allocated_data(::data::VALUE* data);

  // @@protoc_insertion_point(class_scope:client.command_hmapget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::client::command_reply* state_;
  ::data::VALUE* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmapget_replyImpl();
};
// -------------------------------------------------------------------

class command_hmmapget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmmapget) */ {
 public:
  command_hmmapget();
  virtual ~command_hmmapget();

  command_hmmapget(const command_hmmapget& from);

  inline command_hmmapget& operator=(const command_hmmapget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmmapget(command_hmmapget&& from) noexcept
    : command_hmmapget() {
    *this = ::std::move(from);
  }

  inline command_hmmapget& operator=(command_hmmapget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmmapget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmmapget* internal_default_instance() {
    return reinterpret_cast<const command_hmmapget*>(
               &_command_hmmapget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    84;

  void Swap(command_hmmapget* other);
  friend void swap(command_hmmapget& a, command_hmmapget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmmapget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmmapget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmmapget& from);
  void MergeFrom(const command_hmmapget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmmapget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmmapget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmmapgetImpl();
};
// -------------------------------------------------------------------

class command_hmmapget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmmapget_reply) */ {
 public:
  command_hmmapget_reply();
  virtual ~command_hmmapget_reply();

  command_hmmapget_reply(const command_hmmapget_reply& from);

  inline command_hmmapget_reply& operator=(const command_hmmapget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmmapget_reply(command_hmmapget_reply&& from) noexcept
    : command_hmmapget_reply() {
    *this = ::std::move(from);
  }

  inline command_hmmapget_reply& operator=(command_hmmapget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmmapget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmmapget_reply* internal_default_instance() {
    return reinterpret_cast<const command_hmmapget_reply*>(
               &_command_hmmapget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    85;

  void Swap(command_hmmapget_reply* other);
  friend void swap(command_hmmapget_reply& a, command_hmmapget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmmapget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmmapget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmmapget_reply& from);
  void MergeFrom(const command_hmmapget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmmapget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .data.VALUE data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::data::VALUE& data(int index) const;
  ::data::VALUE* mutable_data(int index);
  ::data::VALUE* add_data();
  ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_hmmapget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::data::VALUE > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmmapget_replyImpl();
};
// -------------------------------------------------------------------

class command_mhmmapget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmmapget) */ {
 public:
  command_mhmmapget();
  virtual ~command_mhmmapget();

  command_mhmmapget(const command_mhmmapget& from);

  inline command_mhmmapget& operator=(const command_mhmmapget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmmapget(command_mhmmapget&& from) noexcept
    : command_mhmmapget() {
    *this = ::std::move(from);
  }

  inline command_mhmmapget& operator=(command_mhmmapget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmmapget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmmapget* internal_default_instance() {
    return reinterpret_cast<const command_mhmmapget*>(
               &_command_mhmmapget_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    86;

  void Swap(command_mhmmapget* other);
  friend void swap(command_mhmmapget& a, command_mhmmapget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmmapget* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmmapget* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmmapget& from);
  void MergeFrom(const command_mhmmapget& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmmapget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:client.command_mhmmapget)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmmapgetImpl();
};
// -------------------------------------------------------------------

class command_mhmmapget_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmmapget_reply) */ {
 public:
  command_mhmmapget_reply();
  virtual ~command_mhmmapget_reply();

  command_mhmmapget_reply(const command_mhmmapget_reply& from);

  inline command_mhmmapget_reply& operator=(const command_mhmmapget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmmapget_reply(command_mhmmapget_reply&& from) noexcept
    : command_mhmmapget_reply() {
    *this = ::std::move(from);
  }

  inline command_mhmmapget_reply& operator=(command_mhmmapget_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmmapget_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmmapget_reply* internal_default_instance() {
    return reinterpret_cast<const command_mhmmapget_reply*>(
               &_command_mhmmapget_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    87;

  void Swap(command_mhmmapget_reply* other);
  friend void swap(command_mhmmapget_reply& a, command_mhmmapget_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmmapget_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmmapget_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmmapget_reply& from);
  void MergeFrom(const command_mhmmapget_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmmapget_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.values_type data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::client::values_type& data(int index) const;
  ::client::values_type* mutable_data(int index);
  ::client::values_type* add_data();
  ::google::protobuf::RepeatedPtrField< ::client::values_type >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
      data() const;

  // .client.command_reply state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::client::command_reply& state() const;
  ::client::command_reply* release_state();
  ::client::command_reply* mutable_state();
  void set_allocated_state(::client::command_reply* state);

  // @@protoc_insertion_point(class_scope:client.command_mhmmapget_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::client::values_type > data_;
  ::client::command_reply* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmmapget_replyImpl();
};
// -------------------------------------------------------------------

class command_mapset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mapset) */ {
 public:
  command_mapset();
  virtual ~command_mapset();

  command_mapset(const command_mapset& from);

  inline command_mapset& operator=(const command_mapset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mapset(command_mapset&& from) noexcept
    : command_mapset() {
    *this = ::std::move(from);
  }

  inline command_mapset& operator=(command_mapset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mapset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mapset* internal_default_instance() {
    return reinterpret_cast<const command_mapset*>(
               &_command_mapset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    88;

  void Swap(command_mapset* other);
  friend void swap(command_mapset& a, command_mapset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mapset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mapset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mapset& from);
  void MergeFrom(const command_mapset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mapset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .data.VALUE value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_mapset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mapsetImpl();
};
// -------------------------------------------------------------------

class command_mmapset_KvsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mmapset_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mmapset_KvsEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mmapset_KvsEntry_DoNotUse();
  command_mmapset_KvsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mmapset_KvsEntry_DoNotUse& other);
  static const command_mmapset_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mmapset_KvsEntry_DoNotUse*>(&_command_mmapset_KvsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mmapset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mmapset) */ {
 public:
  command_mmapset();
  virtual ~command_mmapset();

  command_mmapset(const command_mmapset& from);

  inline command_mmapset& operator=(const command_mmapset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mmapset(command_mmapset&& from) noexcept
    : command_mmapset() {
    *this = ::std::move(from);
  }

  inline command_mmapset& operator=(command_mmapset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mmapset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mmapset* internal_default_instance() {
    return reinterpret_cast<const command_mmapset*>(
               &_command_mmapset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    90;

  void Swap(command_mmapset* other);
  friend void swap(command_mmapset& a, command_mmapset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mmapset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mmapset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mmapset& from);
  void MergeFrom(const command_mmapset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mmapset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> kvs = 1;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      kvs() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:client.command_mmapset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_mmapset_KvsEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kvs_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mmapsetImpl();
};
// -------------------------------------------------------------------

class command_hmapset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmapset) */ {
 public:
  command_hmapset();
  virtual ~command_hmapset();

  command_hmapset(const command_hmapset& from);

  inline command_hmapset& operator=(const command_hmapset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmapset(command_hmapset&& from) noexcept
    : command_hmapset() {
    *this = ::std::move(from);
  }

  inline command_hmapset& operator=(command_hmapset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmapset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmapset* internal_default_instance() {
    return reinterpret_cast<const command_hmapset*>(
               &_command_hmapset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    91;

  void Swap(command_hmapset* other);
  friend void swap(command_hmapset& a, command_hmapset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmapset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmapset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmapset& from);
  void MergeFrom(const command_hmapset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmapset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // .data.VALUE value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::data::VALUE& value() const;
  ::data::VALUE* release_value();
  ::data::VALUE* mutable_value();
  void set_allocated_value(::data::VALUE* value);

  // @@protoc_insertion_point(class_scope:client.command_hmapset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::data::VALUE* value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmapsetImpl();
};
// -------------------------------------------------------------------

class command_hmmapset_ValuesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_hmmapset_ValuesEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_hmmapset_ValuesEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_hmmapset_ValuesEntry_DoNotUse();
  command_hmmapset_ValuesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_hmmapset_ValuesEntry_DoNotUse& other);
  static const command_hmmapset_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_hmmapset_ValuesEntry_DoNotUse*>(&_command_hmmapset_ValuesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_hmmapset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmmapset) */ {
 public:
  command_hmmapset();
  virtual ~command_hmmapset();

  command_hmmapset(const command_hmmapset& from);

  inline command_hmmapset& operator=(const command_hmmapset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmmapset(command_hmmapset&& from) noexcept
    : command_hmmapset() {
    *this = ::std::move(from);
  }

  inline command_hmmapset& operator=(command_hmmapset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmmapset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmmapset* internal_default_instance() {
    return reinterpret_cast<const command_hmmapset*>(
               &_command_hmmapset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    93;

  void Swap(command_hmmapset* other);
  friend void swap(command_hmmapset& a, command_hmmapset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmmapset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmmapset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmmapset& from);
  void MergeFrom(const command_hmmapset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmmapset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .data.VALUE> values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      values() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_values();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmmapset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      command_hmmapset_ValuesEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > values_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmmapsetImpl();
};
// -------------------------------------------------------------------

class command_mhmmapset_ValuesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mhmmapset_ValuesEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mhmmapset_ValuesEntry_DoNotUse, 
    ::std::string, ::data::VALUE,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mhmmapset_ValuesEntry_DoNotUse();
  command_mhmmapset_ValuesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mhmmapset_ValuesEntry_DoNotUse& other);
  static const command_mhmmapset_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mhmmapset_ValuesEntry_DoNotUse*>(&_command_mhmmapset_ValuesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mhmmapset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmmapset) */ {
 public:
  command_mhmmapset();
  virtual ~command_mhmmapset();

  command_mhmmapset(const command_mhmmapset& from);

  inline command_mhmmapset& operator=(const command_mhmmapset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmmapset(command_mhmmapset&& from) noexcept
    : command_mhmmapset() {
    *this = ::std::move(from);
  }

  inline command_mhmmapset& operator=(command_mhmmapset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmmapset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmmapset* internal_default_instance() {
    return reinterpret_cast<const command_mhmmapset*>(
               &_command_mhmmapset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    95;

  void Swap(command_mhmmapset* other);
  friend void swap(command_mhmmapset& a, command_mhmmapset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmmapset* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmmapset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmmapset& from);
  void MergeFrom(const command_mhmmapset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmmapset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  const ::std::string& fields(int index) const;
  ::std::string* mutable_fields(int index);
  void set_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fields(int index, ::std::string&& value);
  #endif
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  ::std::string* add_fields();
  void add_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_fields(::std::string&& value);
  #endif
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // map<string, .data.VALUE> values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
      values() const;
  ::google::protobuf::Map< ::std::string, ::data::VALUE >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:client.command_mhmmapset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::internal::MapField<
      command_mhmmapset_ValuesEntry_DoNotUse,
      ::std::string, ::data::VALUE,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > values_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmmapsetImpl();
};
// -------------------------------------------------------------------

class command_mapdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mapdel) */ {
 public:
  command_mapdel();
  virtual ~command_mapdel();

  command_mapdel(const command_mapdel& from);

  inline command_mapdel& operator=(const command_mapdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mapdel(command_mapdel&& from) noexcept
    : command_mapdel() {
    *this = ::std::move(from);
  }

  inline command_mapdel& operator=(command_mapdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mapdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mapdel* internal_default_instance() {
    return reinterpret_cast<const command_mapdel*>(
               &_command_mapdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    96;

  void Swap(command_mapdel* other);
  friend void swap(command_mapdel& a, command_mapdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mapdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mapdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mapdel& from);
  void MergeFrom(const command_mapdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mapdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string mapkeys = 2;
  int mapkeys_size() const;
  void clear_mapkeys();
  static const int kMapkeysFieldNumber = 2;
  const ::std::string& mapkeys(int index) const;
  ::std::string* mutable_mapkeys(int index);
  void set_mapkeys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mapkeys(int index, ::std::string&& value);
  #endif
  void set_mapkeys(int index, const char* value);
  void set_mapkeys(int index, const char* value, size_t size);
  ::std::string* add_mapkeys();
  void add_mapkeys(const ::std::string& value);
  #if LANG_CXX11
  void add_mapkeys(::std::string&& value);
  #endif
  void add_mapkeys(const char* value);
  void add_mapkeys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mapkeys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapkeys();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_mapdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mapkeys_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mapdelImpl();
};
// -------------------------------------------------------------------

class command_mmapdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mmapdel) */ {
 public:
  command_mmapdel();
  virtual ~command_mmapdel();

  command_mmapdel(const command_mmapdel& from);

  inline command_mmapdel& operator=(const command_mmapdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mmapdel(command_mmapdel&& from) noexcept
    : command_mmapdel() {
    *this = ::std::move(from);
  }

  inline command_mmapdel& operator=(command_mmapdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mmapdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mmapdel* internal_default_instance() {
    return reinterpret_cast<const command_mmapdel*>(
               &_command_mmapdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    97;

  void Swap(command_mmapdel* other);
  friend void swap(command_mmapdel& a, command_mmapdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mmapdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mmapdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mmapdel& from);
  void MergeFrom(const command_mmapdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mmapdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string mapkeys = 2;
  int mapkeys_size() const;
  void clear_mapkeys();
  static const int kMapkeysFieldNumber = 2;
  const ::std::string& mapkeys(int index) const;
  ::std::string* mutable_mapkeys(int index);
  void set_mapkeys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mapkeys(int index, ::std::string&& value);
  #endif
  void set_mapkeys(int index, const char* value);
  void set_mapkeys(int index, const char* value, size_t size);
  ::std::string* add_mapkeys();
  void add_mapkeys(const ::std::string& value);
  #if LANG_CXX11
  void add_mapkeys(::std::string&& value);
  #endif
  void add_mapkeys(const char* value);
  void add_mapkeys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mapkeys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapkeys();

  // @@protoc_insertion_point(class_scope:client.command_mmapdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mapkeys_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mmapdelImpl();
};
// -------------------------------------------------------------------

class command_hmapdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmapdel) */ {
 public:
  command_hmapdel();
  virtual ~command_hmapdel();

  command_hmapdel(const command_hmapdel& from);

  inline command_hmapdel& operator=(const command_hmapdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmapdel(command_hmapdel&& from) noexcept
    : command_hmapdel() {
    *this = ::std::move(from);
  }

  inline command_hmapdel& operator=(command_hmapdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmapdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmapdel* internal_default_instance() {
    return reinterpret_cast<const command_hmapdel*>(
               &_command_hmapdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    98;

  void Swap(command_hmapdel* other);
  friend void swap(command_hmapdel& a, command_hmapdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmapdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmapdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmapdel& from);
  void MergeFrom(const command_hmapdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmapdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string mapkeys = 3;
  int mapkeys_size() const;
  void clear_mapkeys();
  static const int kMapkeysFieldNumber = 3;
  const ::std::string& mapkeys(int index) const;
  ::std::string* mutable_mapkeys(int index);
  void set_mapkeys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mapkeys(int index, ::std::string&& value);
  #endif
  void set_mapkeys(int index, const char* value);
  void set_mapkeys(int index, const char* value, size_t size);
  ::std::string* add_mapkeys();
  void add_mapkeys(const ::std::string& value);
  #if LANG_CXX11
  void add_mapkeys(::std::string&& value);
  #endif
  void add_mapkeys(const char* value);
  void add_mapkeys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mapkeys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapkeys();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string field = 2;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:client.command_hmapdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mapkeys_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmapdelImpl();
};
// -------------------------------------------------------------------

class command_hmmapdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_hmmapdel) */ {
 public:
  command_hmmapdel();
  virtual ~command_hmmapdel();

  command_hmmapdel(const command_hmmapdel& from);

  inline command_hmmapdel& operator=(const command_hmmapdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_hmmapdel(command_hmmapdel&& from) noexcept
    : command_hmmapdel() {
    *this = ::std::move(from);
  }

  inline command_hmmapdel& operator=(command_hmmapdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_hmmapdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_hmmapdel* internal_default_instance() {
    return reinterpret_cast<const command_hmmapdel*>(
               &_command_hmmapdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    99;

  void Swap(command_hmmapdel* other);
  friend void swap(command_hmmapdel& a, command_hmmapdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_hmmapdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_hmmapdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_hmmapdel& from);
  void MergeFrom(const command_hmmapdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_hmmapdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field = 2;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::std::string& field(int index) const;
  ::std::string* mutable_field(int index);
  void set_field(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field(int index, ::std::string&& value);
  #endif
  void set_field(int index, const char* value);
  void set_field(int index, const char* value, size_t size);
  ::std::string* add_field();
  void add_field(const ::std::string& value);
  #if LANG_CXX11
  void add_field(::std::string&& value);
  #endif
  void add_field(const char* value);
  void add_field(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field();

  // repeated string mapkeys = 3;
  int mapkeys_size() const;
  void clear_mapkeys();
  static const int kMapkeysFieldNumber = 3;
  const ::std::string& mapkeys(int index) const;
  ::std::string* mutable_mapkeys(int index);
  void set_mapkeys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mapkeys(int index, ::std::string&& value);
  #endif
  void set_mapkeys(int index, const char* value);
  void set_mapkeys(int index, const char* value, size_t size);
  ::std::string* add_mapkeys();
  void add_mapkeys(const ::std::string& value);
  #if LANG_CXX11
  void add_mapkeys(::std::string&& value);
  #endif
  void add_mapkeys(const char* value);
  void add_mapkeys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mapkeys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapkeys();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:client.command_hmmapdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mapkeys_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_hmmapdelImpl();
};
// -------------------------------------------------------------------

class command_mhmmapdel_ValuesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<command_mhmmapdel_ValuesEntry_DoNotUse, 
    ::std::string, ::client::keys_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<command_mhmmapdel_ValuesEntry_DoNotUse, 
    ::std::string, ::client::keys_type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  command_mhmmapdel_ValuesEntry_DoNotUse();
  command_mhmmapdel_ValuesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const command_mhmmapdel_ValuesEntry_DoNotUse& other);
  static const command_mhmmapdel_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const command_mhmmapdel_ValuesEntry_DoNotUse*>(&_command_mhmmapdel_ValuesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class command_mhmmapdel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_mhmmapdel) */ {
 public:
  command_mhmmapdel();
  virtual ~command_mhmmapdel();

  command_mhmmapdel(const command_mhmmapdel& from);

  inline command_mhmmapdel& operator=(const command_mhmmapdel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_mhmmapdel(command_mhmmapdel&& from) noexcept
    : command_mhmmapdel() {
    *this = ::std::move(from);
  }

  inline command_mhmmapdel& operator=(command_mhmmapdel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_mhmmapdel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_mhmmapdel* internal_default_instance() {
    return reinterpret_cast<const command_mhmmapdel*>(
               &_command_mhmmapdel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    101;

  void Swap(command_mhmmapdel* other);
  friend void swap(command_mhmmapdel& a, command_mhmmapdel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_mhmmapdel* New() const PROTOBUF_FINAL { return New(NULL); }

  command_mhmmapdel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_mhmmapdel& from);
  void MergeFrom(const command_mhmmapdel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_mhmmapdel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string field = 1;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::std::string& field(int index) const;
  ::std::string* mutable_field(int index);
  void set_field(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field(int index, ::std::string&& value);
  #endif
  void set_field(int index, const char* value);
  void set_field(int index, const char* value, size_t size);
  ::std::string* add_field();
  void add_field(const ::std::string& value);
  #if LANG_CXX11
  void add_field(::std::string&& value);
  #endif
  void add_field(const char* value);
  void add_field(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field();

  // map<string, .client.keys_type> values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::client::keys_type >&
      values() const;
  ::google::protobuf::Map< ::std::string, ::client::keys_type >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:client.command_mhmmapdel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_;
  ::google::protobuf::internal::MapField<
      command_mhmmapdel_ValuesEntry_DoNotUse,
      ::std::string, ::client::keys_type,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > values_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_mhmmapdelImpl();
};
// -------------------------------------------------------------------

class command_meet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:client.command_meet) */ {
 public:
  command_meet();
  virtual ~command_meet();

  command_meet(const command_meet& from);

  inline command_meet& operator=(const command_meet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  command_meet(command_meet&& from) noexcept
    : command_meet() {
    *this = ::std::move(from);
  }

  inline command_meet& operator=(command_meet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const command_meet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const command_meet* internal_default_instance() {
    return reinterpret_cast<const command_meet*>(
               &_command_meet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    102;

  void Swap(command_meet* other);
  friend void swap(command_meet& a, command_meet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline command_meet* New() const PROTOBUF_FINAL { return New(NULL); }

  command_meet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const command_meet& from);
  void MergeFrom(const command_meet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(command_meet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip = 1;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // int64 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int64 port() const;
  void set_port(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:client.command_meet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int64 port_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultscommand_meetImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// command_reply

// int32 errcode = 1;
inline void command_reply::clear_errcode() {
  errcode_ = 0;
}
inline ::google::protobuf::int32 command_reply::errcode() const {
  // @@protoc_insertion_point(field_get:client.command_reply.errcode)
  return errcode_;
}
inline void command_reply::set_errcode(::google::protobuf::int32 value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:client.command_reply.errcode)
}

// string errmsg = 2;
inline void command_reply::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_reply::errmsg() const {
  // @@protoc_insertion_point(field_get:client.command_reply.errmsg)
  return errmsg_.GetNoArena();
}
inline void command_reply::set_errmsg(const ::std::string& value) {
  
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_reply.errmsg)
}
#if LANG_CXX11
inline void command_reply::set_errmsg(::std::string&& value) {
  
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_reply.errmsg)
}
#endif
inline void command_reply::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_reply.errmsg)
}
inline void command_reply::set_errmsg(const char* value, size_t size) {
  
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_reply.errmsg)
}
inline ::std::string* command_reply::mutable_errmsg() {
  
  // @@protoc_insertion_point(field_mutable:client.command_reply.errmsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_reply::release_errmsg() {
  // @@protoc_insertion_point(field_release:client.command_reply.errmsg)
  
  return errmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_reply::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    
  } else {
    
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:client.command_reply.errmsg)
}

// -------------------------------------------------------------------

// values_type

// repeated .data.VALUE value = 1;
inline int values_type::value_size() const {
  return value_.size();
}
inline const ::data::VALUE& values_type::value(int index) const {
  // @@protoc_insertion_point(field_get:client.values_type.value)
  return value_.Get(index);
}
inline ::data::VALUE* values_type::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:client.values_type.value)
  return value_.Mutable(index);
}
inline ::data::VALUE* values_type::add_value() {
  // @@protoc_insertion_point(field_add:client.values_type.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
values_type::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:client.values_type.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
values_type::value() const {
  // @@protoc_insertion_point(field_list:client.values_type.value)
  return value_;
}

// -------------------------------------------------------------------

// keys_type

// repeated string value = 1;
inline int keys_type::value_size() const {
  return value_.size();
}
inline void keys_type::clear_value() {
  value_.Clear();
}
inline const ::std::string& keys_type::value(int index) const {
  // @@protoc_insertion_point(field_get:client.keys_type.value)
  return value_.Get(index);
}
inline ::std::string* keys_type::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:client.keys_type.value)
  return value_.Mutable(index);
}
inline void keys_type::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.keys_type.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void keys_type::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.keys_type.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void keys_type::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.keys_type.value)
}
inline void keys_type::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.keys_type.value)
}
inline ::std::string* keys_type::add_value() {
  // @@protoc_insertion_point(field_add_mutable:client.keys_type.value)
  return value_.Add();
}
inline void keys_type::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.keys_type.value)
}
#if LANG_CXX11
inline void keys_type::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.keys_type.value)
}
#endif
inline void keys_type::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.keys_type.value)
}
inline void keys_type::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.keys_type.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
keys_type::value() const {
  // @@protoc_insertion_point(field_list:client.keys_type.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
keys_type::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:client.keys_type.value)
  return &value_;
}

// -------------------------------------------------------------------

// command_set

// string key = 1;
inline void command_set::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_set::key() const {
  // @@protoc_insertion_point(field_get:client.command_set.key)
  return key_.GetNoArena();
}
inline void command_set::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_set.key)
}
#if LANG_CXX11
inline void command_set::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_set.key)
}
#endif
inline void command_set::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_set.key)
}
inline void command_set::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_set.key)
}
inline ::std::string* command_set::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_set.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_set::release_key() {
  // @@protoc_insertion_point(field_release:client.command_set.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_set::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_set.key)
}

// .data.VALUE value = 2;
inline bool command_set::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_set::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_set.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_set::release_value() {
  // @@protoc_insertion_point(field_release:client.command_set.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_set::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_set.value)
  return value_;
}
inline void command_set::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_set.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mset

// map<string, .data.VALUE> kvs = 1;
inline int command_mset::kvs_size() const {
  return kvs_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_mset::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_mset.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_mset::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mset.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// command_hset

// string key = 1;
inline void command_hset::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hset::key() const {
  // @@protoc_insertion_point(field_get:client.command_hset.key)
  return key_.GetNoArena();
}
inline void command_hset::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hset.key)
}
#if LANG_CXX11
inline void command_hset::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hset.key)
}
#endif
inline void command_hset::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hset.key)
}
inline void command_hset::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hset.key)
}
inline ::std::string* command_hset::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hset.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hset::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hset.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hset::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hset.key)
}

// string field = 2;
inline void command_hset::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hset::field() const {
  // @@protoc_insertion_point(field_get:client.command_hset.field)
  return field_.GetNoArena();
}
inline void command_hset::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hset.field)
}
#if LANG_CXX11
inline void command_hset::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hset.field)
}
#endif
inline void command_hset::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hset.field)
}
inline void command_hset::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hset.field)
}
inline ::std::string* command_hset::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hset.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hset::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hset.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hset::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hset.field)
}

// .data.VALUE value = 3;
inline bool command_hset::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_hset::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_hset.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hset::release_value() {
  // @@protoc_insertion_point(field_release:client.command_hset.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hset::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hset.value)
  return value_;
}
inline void command_hset::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_hset.value)
}

// int64 ttl = 4;
inline void command_hset::clear_ttl() {
  ttl_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 command_hset::ttl() const {
  // @@protoc_insertion_point(field_get:client.command_hset.ttl)
  return ttl_;
}
inline void command_hset::set_ttl(::google::protobuf::int64 value) {
  
  ttl_ = value;
  // @@protoc_insertion_point(field_set:client.command_hset.ttl)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_hmset

// string key = 1;
inline void command_hmset::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmset::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmset.key)
  return key_.GetNoArena();
}
inline void command_hmset::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmset.key)
}
#if LANG_CXX11
inline void command_hmset::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmset.key)
}
#endif
inline void command_hmset::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmset.key)
}
inline void command_hmset::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmset.key)
}
inline ::std::string* command_hmset::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmset.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmset::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmset.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmset::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmset.key)
}

// map<string, .data.VALUE> values = 2;
inline int command_hmset::values_size() const {
  return values_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_hmset::values() const {
  // @@protoc_insertion_point(field_map:client.command_hmset.values)
  return values_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_hmset::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:client.command_hmset.values)
  return values_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mhmset

// repeated string fields = 1;
inline int command_mhmset::fields_size() const {
  return fields_.size();
}
inline void command_mhmset::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmset::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmset.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmset::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmset.fields)
  return fields_.Mutable(index);
}
inline void command_mhmset::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmset.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmset::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmset.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmset::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmset.fields)
}
inline void command_mhmset::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmset.fields)
}
inline ::std::string* command_mhmset::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmset.fields)
  return fields_.Add();
}
inline void command_mhmset::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmset.fields)
}
#if LANG_CXX11
inline void command_mhmset::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmset.fields)
}
#endif
inline void command_mhmset::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmset.fields)
}
inline void command_mhmset::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmset.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmset::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmset.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmset::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmset.fields)
  return &fields_;
}

// map<string, .client.values_type> values = 2;
inline int command_mhmset::values_size() const {
  return values_.size();
}
inline void command_mhmset::clear_values() {
  values_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::client::values_type >&
command_mhmset::values() const {
  // @@protoc_insertion_point(field_map:client.command_mhmset.values)
  return values_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::client::values_type >*
command_mhmset::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mhmset.values)
  return values_.MutableMap();
}

// -------------------------------------------------------------------

// command_get

// string key = 1;
inline void command_get::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_get::key() const {
  // @@protoc_insertion_point(field_get:client.command_get.key)
  return key_.GetNoArena();
}
inline void command_get::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_get.key)
}
#if LANG_CXX11
inline void command_get::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_get.key)
}
#endif
inline void command_get::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_get.key)
}
inline void command_get::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_get.key)
}
inline ::std::string* command_get::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_get.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_get::release_key() {
  // @@protoc_insertion_point(field_release:client.command_get.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_get::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_get.key)
}

// -------------------------------------------------------------------

// command_get_reply

// .client.command_reply state = 1;
inline bool command_get_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_get_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_get_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_get_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_get_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_get_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_get_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_get_reply.state)
  return state_;
}
inline void command_get_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_get_reply.state)
}

// .data.VALUE data = 2;
inline bool command_get_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_get_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_get_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_get_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_get_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_get_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_get_reply.data)
  return data_;
}
inline void command_get_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_get_reply.data)
}

// -------------------------------------------------------------------

// command_mget

// repeated string keys = 1;
inline int command_mget::keys_size() const {
  return keys_.size();
}
inline void command_mget::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mget::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mget.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mget::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mget.keys)
  return keys_.Mutable(index);
}
inline void command_mget::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mget.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mget::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mget.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mget::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mget.keys)
}
inline void command_mget::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mget.keys)
}
inline ::std::string* command_mget::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mget.keys)
  return keys_.Add();
}
inline void command_mget::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mget.keys)
}
#if LANG_CXX11
inline void command_mget::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mget.keys)
}
#endif
inline void command_mget::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mget.keys)
}
inline void command_mget::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mget.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mget::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mget.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mget::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mget.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// command_mget_reply

// .client.command_reply state = 1;
inline bool command_mget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mget_reply.state)
  return state_;
}
inline void command_mget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mget_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_mget_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_mget_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mget_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_mget_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mget_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_mget_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mget_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_mget_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mget_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_mget_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mget_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_hget

// string key = 1;
inline void command_hget::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hget::key() const {
  // @@protoc_insertion_point(field_get:client.command_hget.key)
  return key_.GetNoArena();
}
inline void command_hget::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hget.key)
}
#if LANG_CXX11
inline void command_hget::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hget.key)
}
#endif
inline void command_hget::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hget.key)
}
inline void command_hget::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hget.key)
}
inline ::std::string* command_hget::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hget.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hget::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hget.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hget::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hget.key)
}

// string field = 2;
inline void command_hget::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hget::field() const {
  // @@protoc_insertion_point(field_get:client.command_hget.field)
  return field_.GetNoArena();
}
inline void command_hget::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hget.field)
}
#if LANG_CXX11
inline void command_hget::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hget.field)
}
#endif
inline void command_hget::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hget.field)
}
inline void command_hget::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hget.field)
}
inline ::std::string* command_hget::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hget.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hget::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hget.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hget::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hget.field)
}

// -------------------------------------------------------------------

// command_hget_reply

// .client.command_reply state = 1;
inline bool command_hget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hget_reply.state)
  return state_;
}
inline void command_hget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hget_reply.state)
}

// .data.VALUE data = 2;
inline bool command_hget_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_hget_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_hget_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hget_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_hget_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hget_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hget_reply.data)
  return data_;
}
inline void command_hget_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_hget_reply.data)
}

// -------------------------------------------------------------------

// command_hmget

// string key = 1;
inline void command_hmget::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmget::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmget.key)
  return key_.GetNoArena();
}
inline void command_hmget::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmget.key)
}
#if LANG_CXX11
inline void command_hmget::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmget.key)
}
#endif
inline void command_hmget::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmget.key)
}
inline void command_hmget::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmget.key)
}
inline ::std::string* command_hmget::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmget.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmget::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmget.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmget::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmget.key)
}

// repeated string fields = 2;
inline int command_hmget::fields_size() const {
  return fields_.size();
}
inline void command_hmget::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_hmget::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmget.fields)
  return fields_.Get(index);
}
inline ::std::string* command_hmget::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmget.fields)
  return fields_.Mutable(index);
}
inline void command_hmget::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmget.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmget::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmget.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmget::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmget.fields)
}
inline void command_hmget::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmget.fields)
}
inline ::std::string* command_hmget::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmget.fields)
  return fields_.Add();
}
inline void command_hmget::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmget.fields)
}
#if LANG_CXX11
inline void command_hmget::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmget.fields)
}
#endif
inline void command_hmget::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmget.fields)
}
inline void command_hmget::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmget.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmget::fields() const {
  // @@protoc_insertion_point(field_list:client.command_hmget.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmget::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmget.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_hmget_reply

// .client.command_reply state = 1;
inline bool command_hmget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hmget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hmget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hmget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hmget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hmget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hmget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmget_reply.state)
  return state_;
}
inline void command_hmget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmget_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_hmget_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_hmget_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmget_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_hmget_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmget_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_hmget_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_hmget_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_hmget_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmget_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_hmget_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_hmget_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mhmget

// repeated string keys = 1;
inline int command_mhmget::keys_size() const {
  return keys_.size();
}
inline void command_mhmget::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmget::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmget.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmget::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmget.keys)
  return keys_.Mutable(index);
}
inline void command_mhmget::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmget.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmget::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmget.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmget::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmget.keys)
}
inline void command_mhmget::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmget.keys)
}
inline ::std::string* command_mhmget::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmget.keys)
  return keys_.Add();
}
inline void command_mhmget::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmget.keys)
}
#if LANG_CXX11
inline void command_mhmget::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmget.keys)
}
#endif
inline void command_mhmget::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmget.keys)
}
inline void command_mhmget::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmget.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmget::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmget.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmget::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmget.keys)
  return &keys_;
}

// repeated string fields = 2;
inline int command_mhmget::fields_size() const {
  return fields_.size();
}
inline void command_mhmget::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmget::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmget.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmget::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmget.fields)
  return fields_.Mutable(index);
}
inline void command_mhmget::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmget.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmget::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmget.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmget::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmget.fields)
}
inline void command_mhmget::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmget.fields)
}
inline ::std::string* command_mhmget::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmget.fields)
  return fields_.Add();
}
inline void command_mhmget::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmget.fields)
}
#if LANG_CXX11
inline void command_mhmget::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmget.fields)
}
#endif
inline void command_mhmget::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmget.fields)
}
inline void command_mhmget::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmget.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmget::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmget.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmget::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmget.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mhmget_reply

// .client.command_reply state = 1;
inline bool command_mhmget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mhmget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mhmget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mhmget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mhmget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mhmget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mhmget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mhmget_reply.state)
  return state_;
}
inline void command_mhmget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mhmget_reply.state)
}

// map<string, .client.values_type> data = 2;
inline int command_mhmget_reply::data_size() const {
  return data_.size();
}
inline void command_mhmget_reply::clear_data() {
  data_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::client::values_type >&
command_mhmget_reply::data() const {
  // @@protoc_insertion_point(field_map:client.command_mhmget_reply.data)
  return data_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::client::values_type >*
command_mhmget_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mhmget_reply.data)
  return data_.MutableMap();
}

// -------------------------------------------------------------------

// command_del

// string key = 1;
inline void command_del::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_del::key() const {
  // @@protoc_insertion_point(field_get:client.command_del.key)
  return key_.GetNoArena();
}
inline void command_del::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_del.key)
}
#if LANG_CXX11
inline void command_del::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_del.key)
}
#endif
inline void command_del::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_del.key)
}
inline void command_del::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_del.key)
}
inline ::std::string* command_del::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_del.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_del::release_key() {
  // @@protoc_insertion_point(field_release:client.command_del.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_del::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_del.key)
}

// -------------------------------------------------------------------

// command_mdel

// repeated string keys = 1;
inline int command_mdel::keys_size() const {
  return keys_.size();
}
inline void command_mdel::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mdel::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mdel.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mdel::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mdel.keys)
  return keys_.Mutable(index);
}
inline void command_mdel::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mdel.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mdel::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mdel.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mdel::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mdel.keys)
}
inline void command_mdel::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mdel.keys)
}
inline ::std::string* command_mdel::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mdel.keys)
  return keys_.Add();
}
inline void command_mdel::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mdel.keys)
}
#if LANG_CXX11
inline void command_mdel::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mdel.keys)
}
#endif
inline void command_mdel::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mdel.keys)
}
inline void command_mdel::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mdel.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mdel::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mdel.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mdel::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mdel.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// command_hdel

// string key = 1;
inline void command_hdel::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hdel::key() const {
  // @@protoc_insertion_point(field_get:client.command_hdel.key)
  return key_.GetNoArena();
}
inline void command_hdel::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hdel.key)
}
#if LANG_CXX11
inline void command_hdel::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hdel.key)
}
#endif
inline void command_hdel::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hdel.key)
}
inline void command_hdel::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hdel.key)
}
inline ::std::string* command_hdel::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hdel.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hdel::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hdel.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hdel::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hdel.key)
}

// string field = 2;
inline void command_hdel::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hdel::field() const {
  // @@protoc_insertion_point(field_get:client.command_hdel.field)
  return field_.GetNoArena();
}
inline void command_hdel::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hdel.field)
}
#if LANG_CXX11
inline void command_hdel::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hdel.field)
}
#endif
inline void command_hdel::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hdel.field)
}
inline void command_hdel::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hdel.field)
}
inline ::std::string* command_hdel::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hdel.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hdel::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hdel.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hdel::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hdel.field)
}

// -------------------------------------------------------------------

// command_hmdel

// string key = 1;
inline void command_hmdel::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmdel::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmdel.key)
  return key_.GetNoArena();
}
inline void command_hmdel::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmdel.key)
}
#if LANG_CXX11
inline void command_hmdel::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmdel.key)
}
#endif
inline void command_hmdel::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmdel.key)
}
inline void command_hmdel::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmdel.key)
}
inline ::std::string* command_hmdel::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmdel.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmdel::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmdel.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmdel::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmdel.key)
}

// repeated string fields = 2;
inline int command_hmdel::fields_size() const {
  return fields_.size();
}
inline void command_hmdel::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_hmdel::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmdel.fields)
  return fields_.Get(index);
}
inline ::std::string* command_hmdel::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmdel.fields)
  return fields_.Mutable(index);
}
inline void command_hmdel::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmdel.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmdel::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmdel.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmdel::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmdel.fields)
}
inline void command_hmdel::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmdel.fields)
}
inline ::std::string* command_hmdel::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmdel.fields)
  return fields_.Add();
}
inline void command_hmdel::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmdel.fields)
}
#if LANG_CXX11
inline void command_hmdel::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmdel.fields)
}
#endif
inline void command_hmdel::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmdel.fields)
}
inline void command_hmdel::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmdel.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmdel::fields() const {
  // @@protoc_insertion_point(field_list:client.command_hmdel.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmdel::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmdel.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_mhmdel

// repeated string keys = 1;
inline int command_mhmdel::keys_size() const {
  return keys_.size();
}
inline void command_mhmdel::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmdel::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmdel.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmdel::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmdel.keys)
  return keys_.Mutable(index);
}
inline void command_mhmdel::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmdel.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmdel::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmdel.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmdel::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmdel.keys)
}
inline void command_mhmdel::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmdel.keys)
}
inline ::std::string* command_mhmdel::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmdel.keys)
  return keys_.Add();
}
inline void command_mhmdel::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmdel.keys)
}
#if LANG_CXX11
inline void command_mhmdel::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmdel.keys)
}
#endif
inline void command_mhmdel::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmdel.keys)
}
inline void command_mhmdel::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmdel.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmdel::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmdel.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmdel::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmdel.keys)
  return &keys_;
}

// repeated string fields = 2;
inline int command_mhmdel::fields_size() const {
  return fields_.size();
}
inline void command_mhmdel::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmdel::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmdel.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmdel::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmdel.fields)
  return fields_.Mutable(index);
}
inline void command_mhmdel::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmdel.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmdel::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmdel.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmdel::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmdel.fields)
}
inline void command_mhmdel::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmdel.fields)
}
inline ::std::string* command_mhmdel::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmdel.fields)
  return fields_.Add();
}
inline void command_mhmdel::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmdel.fields)
}
#if LANG_CXX11
inline void command_mhmdel::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmdel.fields)
}
#endif
inline void command_mhmdel::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmdel.fields)
}
inline void command_mhmdel::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmdel.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmdel::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmdel.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmdel::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmdel.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_incr

// string key = 1;
inline void command_incr::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_incr::key() const {
  // @@protoc_insertion_point(field_get:client.command_incr.key)
  return key_.GetNoArena();
}
inline void command_incr::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_incr.key)
}
#if LANG_CXX11
inline void command_incr::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_incr.key)
}
#endif
inline void command_incr::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_incr.key)
}
inline void command_incr::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_incr.key)
}
inline ::std::string* command_incr::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_incr.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_incr::release_key() {
  // @@protoc_insertion_point(field_release:client.command_incr.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_incr::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_incr.key)
}

// .data.VALUE value = 2;
inline bool command_incr::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_incr::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_incr.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_incr::release_value() {
  // @@protoc_insertion_point(field_release:client.command_incr.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_incr::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_incr.value)
  return value_;
}
inline void command_incr::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_incr.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mincr

// map<string, .data.VALUE> kvs = 1;
inline int command_mincr::kvs_size() const {
  return kvs_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_mincr::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_mincr.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_mincr::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mincr.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// command_hincr

// string key = 1;
inline void command_hincr::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hincr::key() const {
  // @@protoc_insertion_point(field_get:client.command_hincr.key)
  return key_.GetNoArena();
}
inline void command_hincr::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hincr.key)
}
#if LANG_CXX11
inline void command_hincr::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hincr.key)
}
#endif
inline void command_hincr::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hincr.key)
}
inline void command_hincr::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hincr.key)
}
inline ::std::string* command_hincr::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hincr.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hincr::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hincr.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hincr::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hincr.key)
}

// string field = 2;
inline void command_hincr::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hincr::field() const {
  // @@protoc_insertion_point(field_get:client.command_hincr.field)
  return field_.GetNoArena();
}
inline void command_hincr::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hincr.field)
}
#if LANG_CXX11
inline void command_hincr::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hincr.field)
}
#endif
inline void command_hincr::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hincr.field)
}
inline void command_hincr::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hincr.field)
}
inline ::std::string* command_hincr::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hincr.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hincr::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hincr.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hincr::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hincr.field)
}

// .data.VALUE value = 3;
inline bool command_hincr::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_hincr::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_hincr.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hincr::release_value() {
  // @@protoc_insertion_point(field_release:client.command_hincr.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hincr::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hincr.value)
  return value_;
}
inline void command_hincr::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_hincr.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_hmincr

// string key = 1;
inline void command_hmincr::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmincr::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmincr.key)
  return key_.GetNoArena();
}
inline void command_hmincr::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmincr.key)
}
#if LANG_CXX11
inline void command_hmincr::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmincr.key)
}
#endif
inline void command_hmincr::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmincr.key)
}
inline void command_hmincr::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmincr.key)
}
inline ::std::string* command_hmincr::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmincr.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmincr::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmincr.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmincr::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmincr.key)
}

// map<string, .data.VALUE> kvs = 2;
inline int command_hmincr::kvs_size() const {
  return kvs_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_hmincr::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_hmincr.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_hmincr::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_hmincr.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mhmincr

// repeated string fields = 1;
inline int command_mhmincr::fields_size() const {
  return fields_.size();
}
inline void command_mhmincr::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmincr::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmincr.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmincr::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmincr.fields)
  return fields_.Mutable(index);
}
inline void command_mhmincr::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmincr.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmincr::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmincr.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmincr::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmincr.fields)
}
inline void command_mhmincr::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmincr.fields)
}
inline ::std::string* command_mhmincr::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmincr.fields)
  return fields_.Add();
}
inline void command_mhmincr::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmincr.fields)
}
#if LANG_CXX11
inline void command_mhmincr::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmincr.fields)
}
#endif
inline void command_mhmincr::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmincr.fields)
}
inline void command_mhmincr::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmincr.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmincr::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmincr.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmincr::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmincr.fields)
  return &fields_;
}

// map<string, .client.values_type> kvs = 2;
inline int command_mhmincr::kvs_size() const {
  return kvs_.size();
}
inline void command_mhmincr::clear_kvs() {
  kvs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::client::values_type >&
command_mhmincr::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_mhmincr.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::client::values_type >*
command_mhmincr::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mhmincr.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// command_lpush

// string key = 1;
inline void command_lpush::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_lpush::key() const {
  // @@protoc_insertion_point(field_get:client.command_lpush.key)
  return key_.GetNoArena();
}
inline void command_lpush::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_lpush.key)
}
#if LANG_CXX11
inline void command_lpush::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_lpush.key)
}
#endif
inline void command_lpush::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_lpush.key)
}
inline void command_lpush::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_lpush.key)
}
inline ::std::string* command_lpush::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_lpush.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_lpush::release_key() {
  // @@protoc_insertion_point(field_release:client.command_lpush.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_lpush::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_lpush.key)
}

// .data.VALUE value = 2;
inline bool command_lpush::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_lpush::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_lpush.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_lpush::release_value() {
  // @@protoc_insertion_point(field_release:client.command_lpush.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_lpush::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_lpush.value)
  return value_;
}
inline void command_lpush::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_lpush.value)
}

// bool head = 3;
inline void command_lpush::clear_head() {
  head_ = false;
}
inline bool command_lpush::head() const {
  // @@protoc_insertion_point(field_get:client.command_lpush.head)
  return head_;
}
inline void command_lpush::set_head(bool value) {
  
  head_ = value;
  // @@protoc_insertion_point(field_set:client.command_lpush.head)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mlpush

// map<string, .data.VALUE> kvs = 1;
inline int command_mlpush::kvs_size() const {
  return kvs_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_mlpush::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_mlpush.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_mlpush::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mlpush.kvs)
  return kvs_.MutableMap();
}

// bool head = 2;
inline void command_mlpush::clear_head() {
  head_ = false;
}
inline bool command_mlpush::head() const {
  // @@protoc_insertion_point(field_get:client.command_mlpush.head)
  return head_;
}
inline void command_mlpush::set_head(bool value) {
  
  head_ = value;
  // @@protoc_insertion_point(field_set:client.command_mlpush.head)
}

// -------------------------------------------------------------------

// command_hlpush

// string key = 1;
inline void command_hlpush::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hlpush::key() const {
  // @@protoc_insertion_point(field_get:client.command_hlpush.key)
  return key_.GetNoArena();
}
inline void command_hlpush::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hlpush.key)
}
#if LANG_CXX11
inline void command_hlpush::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hlpush.key)
}
#endif
inline void command_hlpush::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hlpush.key)
}
inline void command_hlpush::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hlpush.key)
}
inline ::std::string* command_hlpush::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hlpush.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hlpush::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hlpush.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hlpush::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpush.key)
}

// string field = 2;
inline void command_hlpush::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hlpush::field() const {
  // @@protoc_insertion_point(field_get:client.command_hlpush.field)
  return field_.GetNoArena();
}
inline void command_hlpush::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hlpush.field)
}
#if LANG_CXX11
inline void command_hlpush::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hlpush.field)
}
#endif
inline void command_hlpush::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hlpush.field)
}
inline void command_hlpush::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hlpush.field)
}
inline ::std::string* command_hlpush::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hlpush.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hlpush::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hlpush.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hlpush::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpush.field)
}

// .data.VALUE value = 3;
inline bool command_hlpush::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_hlpush::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_hlpush.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hlpush::release_value() {
  // @@protoc_insertion_point(field_release:client.command_hlpush.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hlpush::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hlpush.value)
  return value_;
}
inline void command_hlpush::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpush.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_hmlpush

// string key = 1;
inline void command_hmlpush::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmlpush::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmlpush.key)
  return key_.GetNoArena();
}
inline void command_hmlpush::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmlpush.key)
}
#if LANG_CXX11
inline void command_hmlpush::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmlpush.key)
}
#endif
inline void command_hmlpush::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmlpush.key)
}
inline void command_hmlpush::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmlpush.key)
}
inline ::std::string* command_hmlpush::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmlpush.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmlpush::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmlpush.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmlpush::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmlpush.key)
}

// map<string, .data.VALUE> kvs = 2;
inline int command_hmlpush::kvs_size() const {
  return kvs_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_hmlpush::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_hmlpush.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_hmlpush::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_hmlpush.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mhmlpush

// repeated string fields = 1;
inline int command_mhmlpush::fields_size() const {
  return fields_.size();
}
inline void command_mhmlpush::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmlpush::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlpush.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmlpush::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlpush.fields)
  return fields_.Mutable(index);
}
inline void command_mhmlpush::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlpush.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmlpush::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlpush.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmlpush::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmlpush.fields)
}
inline void command_mhmlpush::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmlpush.fields)
}
inline ::std::string* command_mhmlpush::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmlpush.fields)
  return fields_.Add();
}
inline void command_mhmlpush::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmlpush.fields)
}
#if LANG_CXX11
inline void command_mhmlpush::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmlpush.fields)
}
#endif
inline void command_mhmlpush::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmlpush.fields)
}
inline void command_mhmlpush::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmlpush.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmlpush::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlpush.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmlpush::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlpush.fields)
  return &fields_;
}

// map<string, .client.values_type> kvs = 2;
inline int command_mhmlpush::kvs_size() const {
  return kvs_.size();
}
inline void command_mhmlpush::clear_kvs() {
  kvs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::client::values_type >&
command_mhmlpush::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_mhmlpush.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::client::values_type >*
command_mhmlpush::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mhmlpush.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// command_lrange

// string key = 1;
inline void command_lrange::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_lrange::key() const {
  // @@protoc_insertion_point(field_get:client.command_lrange.key)
  return key_.GetNoArena();
}
inline void command_lrange::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_lrange.key)
}
#if LANG_CXX11
inline void command_lrange::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_lrange.key)
}
#endif
inline void command_lrange::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_lrange.key)
}
inline void command_lrange::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_lrange.key)
}
inline ::std::string* command_lrange::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_lrange.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_lrange::release_key() {
  // @@protoc_insertion_point(field_release:client.command_lrange.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_lrange::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_lrange.key)
}

// int32 start = 2;
inline void command_lrange::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_lrange::start() const {
  // @@protoc_insertion_point(field_get:client.command_lrange.start)
  return start_;
}
inline void command_lrange::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_lrange.start)
}

// int32 stop = 3;
inline void command_lrange::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_lrange::stop() const {
  // @@protoc_insertion_point(field_get:client.command_lrange.stop)
  return stop_;
}
inline void command_lrange::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_lrange.stop)
}

// -------------------------------------------------------------------

// command_lrange_reply

// .client.command_reply state = 1;
inline bool command_lrange_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_lrange_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_lrange_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_lrange_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_lrange_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_lrange_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_lrange_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_lrange_reply.state)
  return state_;
}
inline void command_lrange_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_lrange_reply.state)
}

// .data.VALUE data = 2;
inline bool command_lrange_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_lrange_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_lrange_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_lrange_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_lrange_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_lrange_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_lrange_reply.data)
  return data_;
}
inline void command_lrange_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_lrange_reply.data)
}

// -------------------------------------------------------------------

// command_mlrange

// repeated string keys = 1;
inline int command_mlrange::keys_size() const {
  return keys_.size();
}
inline void command_mlrange::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mlrange::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mlrange.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mlrange::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mlrange.keys)
  return keys_.Mutable(index);
}
inline void command_mlrange::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mlrange.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mlrange::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mlrange.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mlrange::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mlrange.keys)
}
inline void command_mlrange::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mlrange.keys)
}
inline ::std::string* command_mlrange::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mlrange.keys)
  return keys_.Add();
}
inline void command_mlrange::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mlrange.keys)
}
#if LANG_CXX11
inline void command_mlrange::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mlrange.keys)
}
#endif
inline void command_mlrange::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mlrange.keys)
}
inline void command_mlrange::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mlrange.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mlrange::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mlrange.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mlrange::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mlrange.keys)
  return &keys_;
}

// int32 start = 2;
inline void command_mlrange::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_mlrange::start() const {
  // @@protoc_insertion_point(field_get:client.command_mlrange.start)
  return start_;
}
inline void command_mlrange::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_mlrange.start)
}

// int32 stop = 3;
inline void command_mlrange::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_mlrange::stop() const {
  // @@protoc_insertion_point(field_get:client.command_mlrange.stop)
  return stop_;
}
inline void command_mlrange::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_mlrange.stop)
}

// -------------------------------------------------------------------

// command_mlrange_reply

// .client.command_reply state = 1;
inline bool command_mlrange_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mlrange_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mlrange_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mlrange_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mlrange_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mlrange_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mlrange_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mlrange_reply.state)
  return state_;
}
inline void command_mlrange_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mlrange_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_mlrange_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_mlrange_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mlrange_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_mlrange_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mlrange_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_mlrange_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mlrange_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_mlrange_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mlrange_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_mlrange_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mlrange_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_hlrange

// string key = 1;
inline void command_hlrange::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hlrange::key() const {
  // @@protoc_insertion_point(field_get:client.command_hlrange.key)
  return key_.GetNoArena();
}
inline void command_hlrange::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hlrange.key)
}
#if LANG_CXX11
inline void command_hlrange::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hlrange.key)
}
#endif
inline void command_hlrange::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hlrange.key)
}
inline void command_hlrange::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hlrange.key)
}
inline ::std::string* command_hlrange::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hlrange.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hlrange::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hlrange.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hlrange::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hlrange.key)
}

// string field = 2;
inline void command_hlrange::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hlrange::field() const {
  // @@protoc_insertion_point(field_get:client.command_hlrange.field)
  return field_.GetNoArena();
}
inline void command_hlrange::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hlrange.field)
}
#if LANG_CXX11
inline void command_hlrange::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hlrange.field)
}
#endif
inline void command_hlrange::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hlrange.field)
}
inline void command_hlrange::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hlrange.field)
}
inline ::std::string* command_hlrange::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hlrange.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hlrange::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hlrange.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hlrange::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hlrange.field)
}

// int32 start = 3;
inline void command_hlrange::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_hlrange::start() const {
  // @@protoc_insertion_point(field_get:client.command_hlrange.start)
  return start_;
}
inline void command_hlrange::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_hlrange.start)
}

// int32 stop = 4;
inline void command_hlrange::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_hlrange::stop() const {
  // @@protoc_insertion_point(field_get:client.command_hlrange.stop)
  return stop_;
}
inline void command_hlrange::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_hlrange.stop)
}

// -------------------------------------------------------------------

// command_hlrange_reply

// .client.command_reply state = 1;
inline bool command_hlrange_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hlrange_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hlrange_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hlrange_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hlrange_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hlrange_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hlrange_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hlrange_reply.state)
  return state_;
}
inline void command_hlrange_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hlrange_reply.state)
}

// .data.VALUE value = 2;
inline bool command_hlrange_reply::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_hlrange_reply::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_hlrange_reply.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hlrange_reply::release_value() {
  // @@protoc_insertion_point(field_release:client.command_hlrange_reply.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hlrange_reply::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hlrange_reply.value)
  return value_;
}
inline void command_hlrange_reply::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_hlrange_reply.value)
}

// -------------------------------------------------------------------

// command_hmlrange

// string key = 1;
inline void command_hmlrange::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmlrange::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmlrange.key)
  return key_.GetNoArena();
}
inline void command_hmlrange::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmlrange.key)
}
#if LANG_CXX11
inline void command_hmlrange::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmlrange.key)
}
#endif
inline void command_hmlrange::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmlrange.key)
}
inline void command_hmlrange::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmlrange.key)
}
inline ::std::string* command_hmlrange::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmlrange.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmlrange::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmlrange.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmlrange::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmlrange.key)
}

// repeated string fields = 2;
inline int command_hmlrange::fields_size() const {
  return fields_.size();
}
inline void command_hmlrange::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_hmlrange::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmlrange.fields)
  return fields_.Get(index);
}
inline ::std::string* command_hmlrange::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmlrange.fields)
  return fields_.Mutable(index);
}
inline void command_hmlrange::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmlrange.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmlrange::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmlrange.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmlrange::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmlrange.fields)
}
inline void command_hmlrange::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmlrange.fields)
}
inline ::std::string* command_hmlrange::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmlrange.fields)
  return fields_.Add();
}
inline void command_hmlrange::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmlrange.fields)
}
#if LANG_CXX11
inline void command_hmlrange::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmlrange.fields)
}
#endif
inline void command_hmlrange::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmlrange.fields)
}
inline void command_hmlrange::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmlrange.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmlrange::fields() const {
  // @@protoc_insertion_point(field_list:client.command_hmlrange.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmlrange::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmlrange.fields)
  return &fields_;
}

// int32 start = 3;
inline void command_hmlrange::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_hmlrange::start() const {
  // @@protoc_insertion_point(field_get:client.command_hmlrange.start)
  return start_;
}
inline void command_hmlrange::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_hmlrange.start)
}

// int32 stop = 4;
inline void command_hmlrange::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_hmlrange::stop() const {
  // @@protoc_insertion_point(field_get:client.command_hmlrange.stop)
  return stop_;
}
inline void command_hmlrange::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_hmlrange.stop)
}

// -------------------------------------------------------------------

// command_hmlrange_reply

// .client.command_reply state = 1;
inline bool command_hmlrange_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hmlrange_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hmlrange_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hmlrange_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hmlrange_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hmlrange_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hmlrange_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmlrange_reply.state)
  return state_;
}
inline void command_hmlrange_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmlrange_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_hmlrange_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_hmlrange_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmlrange_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_hmlrange_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmlrange_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_hmlrange_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_hmlrange_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_hmlrange_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmlrange_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_hmlrange_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_hmlrange_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mhmlrange

// repeated string keys = 1;
inline int command_mhmlrange::keys_size() const {
  return keys_.size();
}
inline void command_mhmlrange::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmlrange::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlrange.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmlrange::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlrange.keys)
  return keys_.Mutable(index);
}
inline void command_mhmlrange::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlrange.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmlrange::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlrange.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmlrange::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmlrange.keys)
}
inline void command_mhmlrange::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmlrange.keys)
}
inline ::std::string* command_mhmlrange::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmlrange.keys)
  return keys_.Add();
}
inline void command_mhmlrange::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmlrange.keys)
}
#if LANG_CXX11
inline void command_mhmlrange::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmlrange.keys)
}
#endif
inline void command_mhmlrange::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmlrange.keys)
}
inline void command_mhmlrange::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmlrange.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmlrange::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlrange.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmlrange::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlrange.keys)
  return &keys_;
}

// repeated string fields = 2;
inline int command_mhmlrange::fields_size() const {
  return fields_.size();
}
inline void command_mhmlrange::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmlrange::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlrange.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmlrange::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlrange.fields)
  return fields_.Mutable(index);
}
inline void command_mhmlrange::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlrange.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmlrange::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlrange.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmlrange::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmlrange.fields)
}
inline void command_mhmlrange::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmlrange.fields)
}
inline ::std::string* command_mhmlrange::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmlrange.fields)
  return fields_.Add();
}
inline void command_mhmlrange::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmlrange.fields)
}
#if LANG_CXX11
inline void command_mhmlrange::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmlrange.fields)
}
#endif
inline void command_mhmlrange::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmlrange.fields)
}
inline void command_mhmlrange::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmlrange.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmlrange::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlrange.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmlrange::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlrange.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_mhmlrange_reply

// .client.command_reply state = 1;
inline bool command_mhmlrange_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mhmlrange_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mhmlrange_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mhmlrange_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mhmlrange_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mhmlrange_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mhmlrange_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mhmlrange_reply.state)
  return state_;
}
inline void command_mhmlrange_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mhmlrange_reply.state)
}

// repeated .client.values_type data = 2;
inline int command_mhmlrange_reply::data_size() const {
  return data_.size();
}
inline void command_mhmlrange_reply::clear_data() {
  data_.Clear();
}
inline const ::client::values_type& command_mhmlrange_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlrange_reply.data)
  return data_.Get(index);
}
inline ::client::values_type* command_mhmlrange_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlrange_reply.data)
  return data_.Mutable(index);
}
inline ::client::values_type* command_mhmlrange_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mhmlrange_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::client::values_type >*
command_mhmlrange_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlrange_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
command_mhmlrange_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlrange_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_lpop

// string key = 1;
inline void command_lpop::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_lpop::key() const {
  // @@protoc_insertion_point(field_get:client.command_lpop.key)
  return key_.GetNoArena();
}
inline void command_lpop::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_lpop.key)
}
#if LANG_CXX11
inline void command_lpop::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_lpop.key)
}
#endif
inline void command_lpop::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_lpop.key)
}
inline void command_lpop::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_lpop.key)
}
inline ::std::string* command_lpop::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_lpop.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_lpop::release_key() {
  // @@protoc_insertion_point(field_release:client.command_lpop.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_lpop::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_lpop.key)
}

// bool head = 2;
inline void command_lpop::clear_head() {
  head_ = false;
}
inline bool command_lpop::head() const {
  // @@protoc_insertion_point(field_get:client.command_lpop.head)
  return head_;
}
inline void command_lpop::set_head(bool value) {
  
  head_ = value;
  // @@protoc_insertion_point(field_set:client.command_lpop.head)
}

// -------------------------------------------------------------------

// command_lpop_reply

// .client.command_reply state = 1;
inline bool command_lpop_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_lpop_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_lpop_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_lpop_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_lpop_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_lpop_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_lpop_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_lpop_reply.state)
  return state_;
}
inline void command_lpop_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_lpop_reply.state)
}

// .data.VALUE data = 2;
inline bool command_lpop_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_lpop_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_lpop_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_lpop_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_lpop_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_lpop_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_lpop_reply.data)
  return data_;
}
inline void command_lpop_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_lpop_reply.data)
}

// -------------------------------------------------------------------

// command_mlpop

// repeated string keys = 1;
inline int command_mlpop::keys_size() const {
  return keys_.size();
}
inline void command_mlpop::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mlpop::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mlpop.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mlpop::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mlpop.keys)
  return keys_.Mutable(index);
}
inline void command_mlpop::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mlpop.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mlpop::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mlpop.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mlpop::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mlpop.keys)
}
inline void command_mlpop::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mlpop.keys)
}
inline ::std::string* command_mlpop::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mlpop.keys)
  return keys_.Add();
}
inline void command_mlpop::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mlpop.keys)
}
#if LANG_CXX11
inline void command_mlpop::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mlpop.keys)
}
#endif
inline void command_mlpop::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mlpop.keys)
}
inline void command_mlpop::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mlpop.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mlpop::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mlpop.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mlpop::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mlpop.keys)
  return &keys_;
}

// bool head = 2;
inline void command_mlpop::clear_head() {
  head_ = false;
}
inline bool command_mlpop::head() const {
  // @@protoc_insertion_point(field_get:client.command_mlpop.head)
  return head_;
}
inline void command_mlpop::set_head(bool value) {
  
  head_ = value;
  // @@protoc_insertion_point(field_set:client.command_mlpop.head)
}

// -------------------------------------------------------------------

// command_mlpop_repy

// .client.command_reply state = 1;
inline bool command_mlpop_repy::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mlpop_repy::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mlpop_repy::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mlpop_repy.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mlpop_repy::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mlpop_repy.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mlpop_repy::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mlpop_repy.state)
  return state_;
}
inline void command_mlpop_repy::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mlpop_repy.state)
}

// repeated .data.VALUE data = 2;
inline int command_mlpop_repy::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_mlpop_repy::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mlpop_repy.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_mlpop_repy::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mlpop_repy.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_mlpop_repy::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mlpop_repy.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_mlpop_repy::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mlpop_repy.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_mlpop_repy::data() const {
  // @@protoc_insertion_point(field_list:client.command_mlpop_repy.data)
  return data_;
}

// -------------------------------------------------------------------

// command_hlpop

// string key = 1;
inline void command_hlpop::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hlpop::key() const {
  // @@protoc_insertion_point(field_get:client.command_hlpop.key)
  return key_.GetNoArena();
}
inline void command_hlpop::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hlpop.key)
}
#if LANG_CXX11
inline void command_hlpop::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hlpop.key)
}
#endif
inline void command_hlpop::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hlpop.key)
}
inline void command_hlpop::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hlpop.key)
}
inline ::std::string* command_hlpop::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hlpop.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hlpop::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hlpop.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hlpop::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpop.key)
}

// string field = 2;
inline void command_hlpop::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hlpop::field() const {
  // @@protoc_insertion_point(field_get:client.command_hlpop.field)
  return field_.GetNoArena();
}
inline void command_hlpop::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hlpop.field)
}
#if LANG_CXX11
inline void command_hlpop::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hlpop.field)
}
#endif
inline void command_hlpop::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hlpop.field)
}
inline void command_hlpop::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hlpop.field)
}
inline ::std::string* command_hlpop::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hlpop.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hlpop::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hlpop.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hlpop::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpop.field)
}

// -------------------------------------------------------------------

// command_hlpop_reply

// .client.command_reply state = 1;
inline bool command_hlpop_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hlpop_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hlpop_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hlpop_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hlpop_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hlpop_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hlpop_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hlpop_reply.state)
  return state_;
}
inline void command_hlpop_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpop_reply.state)
}

// .data.VALUE data = 2;
inline bool command_hlpop_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_hlpop_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_hlpop_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hlpop_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_hlpop_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hlpop_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hlpop_reply.data)
  return data_;
}
inline void command_hlpop_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_hlpop_reply.data)
}

// -------------------------------------------------------------------

// command_hmlpop

// string key = 1;
inline void command_hmlpop::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmlpop::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmlpop.key)
  return key_.GetNoArena();
}
inline void command_hmlpop::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmlpop.key)
}
#if LANG_CXX11
inline void command_hmlpop::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmlpop.key)
}
#endif
inline void command_hmlpop::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmlpop.key)
}
inline void command_hmlpop::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmlpop.key)
}
inline ::std::string* command_hmlpop::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmlpop.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmlpop::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmlpop.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmlpop::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmlpop.key)
}

// repeated string fields = 2;
inline int command_hmlpop::fields_size() const {
  return fields_.size();
}
inline void command_hmlpop::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_hmlpop::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmlpop.fields)
  return fields_.Get(index);
}
inline ::std::string* command_hmlpop::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmlpop.fields)
  return fields_.Mutable(index);
}
inline void command_hmlpop::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmlpop.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmlpop::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmlpop.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmlpop::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmlpop.fields)
}
inline void command_hmlpop::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmlpop.fields)
}
inline ::std::string* command_hmlpop::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmlpop.fields)
  return fields_.Add();
}
inline void command_hmlpop::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmlpop.fields)
}
#if LANG_CXX11
inline void command_hmlpop::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmlpop.fields)
}
#endif
inline void command_hmlpop::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmlpop.fields)
}
inline void command_hmlpop::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmlpop.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmlpop::fields() const {
  // @@protoc_insertion_point(field_list:client.command_hmlpop.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmlpop::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmlpop.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_hmlpop_reply

// .client.command_reply state = 1;
inline bool command_hmlpop_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hmlpop_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hmlpop_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hmlpop_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hmlpop_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hmlpop_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hmlpop_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmlpop_reply.state)
  return state_;
}
inline void command_hmlpop_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmlpop_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_hmlpop_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_hmlpop_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmlpop_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_hmlpop_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmlpop_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_hmlpop_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_hmlpop_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_hmlpop_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmlpop_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_hmlpop_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_hmlpop_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mhmlpop

// repeated string keys = 1;
inline int command_mhmlpop::keys_size() const {
  return keys_.size();
}
inline void command_mhmlpop::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmlpop::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlpop.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmlpop::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlpop.keys)
  return keys_.Mutable(index);
}
inline void command_mhmlpop::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlpop.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmlpop::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlpop.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmlpop::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmlpop.keys)
}
inline void command_mhmlpop::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmlpop.keys)
}
inline ::std::string* command_mhmlpop::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmlpop.keys)
  return keys_.Add();
}
inline void command_mhmlpop::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmlpop.keys)
}
#if LANG_CXX11
inline void command_mhmlpop::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmlpop.keys)
}
#endif
inline void command_mhmlpop::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmlpop.keys)
}
inline void command_mhmlpop::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmlpop.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmlpop::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlpop.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmlpop::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlpop.keys)
  return &keys_;
}

// repeated string fields = 2;
inline int command_mhmlpop::fields_size() const {
  return fields_.size();
}
inline void command_mhmlpop::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmlpop::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlpop.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmlpop::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlpop.fields)
  return fields_.Mutable(index);
}
inline void command_mhmlpop::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlpop.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmlpop::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmlpop.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmlpop::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmlpop.fields)
}
inline void command_mhmlpop::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmlpop.fields)
}
inline ::std::string* command_mhmlpop::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmlpop.fields)
  return fields_.Add();
}
inline void command_mhmlpop::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmlpop.fields)
}
#if LANG_CXX11
inline void command_mhmlpop::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmlpop.fields)
}
#endif
inline void command_mhmlpop::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmlpop.fields)
}
inline void command_mhmlpop::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmlpop.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmlpop::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlpop.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmlpop::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlpop.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_mhmlpop_reply

// .client.command_reply state = 1;
inline bool command_mhmlpop_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mhmlpop_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mhmlpop_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mhmlpop_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mhmlpop_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mhmlpop_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mhmlpop_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mhmlpop_reply.state)
  return state_;
}
inline void command_mhmlpop_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mhmlpop_reply.state)
}

// repeated .client.values_type data = 2;
inline int command_mhmlpop_reply::data_size() const {
  return data_.size();
}
inline void command_mhmlpop_reply::clear_data() {
  data_.Clear();
}
inline const ::client::values_type& command_mhmlpop_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmlpop_reply.data)
  return data_.Get(index);
}
inline ::client::values_type* command_mhmlpop_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmlpop_reply.data)
  return data_.Mutable(index);
}
inline ::client::values_type* command_mhmlpop_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mhmlpop_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::client::values_type >*
command_mhmlpop_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmlpop_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
command_mhmlpop_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mhmlpop_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_ltrim

// string key = 1;
inline void command_ltrim::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_ltrim::key() const {
  // @@protoc_insertion_point(field_get:client.command_ltrim.key)
  return key_.GetNoArena();
}
inline void command_ltrim::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_ltrim.key)
}
#if LANG_CXX11
inline void command_ltrim::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_ltrim.key)
}
#endif
inline void command_ltrim::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_ltrim.key)
}
inline void command_ltrim::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_ltrim.key)
}
inline ::std::string* command_ltrim::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_ltrim.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_ltrim::release_key() {
  // @@protoc_insertion_point(field_release:client.command_ltrim.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_ltrim::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_ltrim.key)
}

// int32 start = 2;
inline void command_ltrim::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_ltrim::start() const {
  // @@protoc_insertion_point(field_get:client.command_ltrim.start)
  return start_;
}
inline void command_ltrim::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_ltrim.start)
}

// int32 stop = 3;
inline void command_ltrim::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_ltrim::stop() const {
  // @@protoc_insertion_point(field_get:client.command_ltrim.stop)
  return stop_;
}
inline void command_ltrim::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_ltrim.stop)
}

// -------------------------------------------------------------------

// command_mltrim

// repeated string keys = 1;
inline int command_mltrim::keys_size() const {
  return keys_.size();
}
inline void command_mltrim::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mltrim::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mltrim.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mltrim::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mltrim.keys)
  return keys_.Mutable(index);
}
inline void command_mltrim::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mltrim.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mltrim::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mltrim.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mltrim::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mltrim.keys)
}
inline void command_mltrim::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mltrim.keys)
}
inline ::std::string* command_mltrim::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mltrim.keys)
  return keys_.Add();
}
inline void command_mltrim::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mltrim.keys)
}
#if LANG_CXX11
inline void command_mltrim::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mltrim.keys)
}
#endif
inline void command_mltrim::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mltrim.keys)
}
inline void command_mltrim::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mltrim.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mltrim::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mltrim.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mltrim::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mltrim.keys)
  return &keys_;
}

// int32 start = 2;
inline void command_mltrim::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_mltrim::start() const {
  // @@protoc_insertion_point(field_get:client.command_mltrim.start)
  return start_;
}
inline void command_mltrim::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_mltrim.start)
}

// int32 stop = 3;
inline void command_mltrim::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_mltrim::stop() const {
  // @@protoc_insertion_point(field_get:client.command_mltrim.stop)
  return stop_;
}
inline void command_mltrim::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_mltrim.stop)
}

// -------------------------------------------------------------------

// command_hltrim

// string key = 1;
inline void command_hltrim::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hltrim::key() const {
  // @@protoc_insertion_point(field_get:client.command_hltrim.key)
  return key_.GetNoArena();
}
inline void command_hltrim::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hltrim.key)
}
#if LANG_CXX11
inline void command_hltrim::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hltrim.key)
}
#endif
inline void command_hltrim::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hltrim.key)
}
inline void command_hltrim::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hltrim.key)
}
inline ::std::string* command_hltrim::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hltrim.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hltrim::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hltrim.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hltrim::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hltrim.key)
}

// string filed = 2;
inline void command_hltrim::clear_filed() {
  filed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hltrim::filed() const {
  // @@protoc_insertion_point(field_get:client.command_hltrim.filed)
  return filed_.GetNoArena();
}
inline void command_hltrim::set_filed(const ::std::string& value) {
  
  filed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hltrim.filed)
}
#if LANG_CXX11
inline void command_hltrim::set_filed(::std::string&& value) {
  
  filed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hltrim.filed)
}
#endif
inline void command_hltrim::set_filed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hltrim.filed)
}
inline void command_hltrim::set_filed(const char* value, size_t size) {
  
  filed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hltrim.filed)
}
inline ::std::string* command_hltrim::mutable_filed() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hltrim.filed)
  return filed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hltrim::release_filed() {
  // @@protoc_insertion_point(field_release:client.command_hltrim.filed)
  
  return filed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hltrim::set_allocated_filed(::std::string* filed) {
  if (filed != NULL) {
    
  } else {
    
  }
  filed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filed);
  // @@protoc_insertion_point(field_set_allocated:client.command_hltrim.filed)
}

// int32 start = 3;
inline void command_hltrim::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_hltrim::start() const {
  // @@protoc_insertion_point(field_get:client.command_hltrim.start)
  return start_;
}
inline void command_hltrim::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_hltrim.start)
}

// int32 stop = 4;
inline void command_hltrim::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_hltrim::stop() const {
  // @@protoc_insertion_point(field_get:client.command_hltrim.stop)
  return stop_;
}
inline void command_hltrim::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_hltrim.stop)
}

// -------------------------------------------------------------------

// command_hmltrim

// string key = 1;
inline void command_hmltrim::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmltrim::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmltrim.key)
  return key_.GetNoArena();
}
inline void command_hmltrim::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmltrim.key)
}
#if LANG_CXX11
inline void command_hmltrim::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmltrim.key)
}
#endif
inline void command_hmltrim::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmltrim.key)
}
inline void command_hmltrim::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmltrim.key)
}
inline ::std::string* command_hmltrim::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmltrim.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmltrim::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmltrim.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmltrim::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmltrim.key)
}

// repeated string fileds = 2;
inline int command_hmltrim::fileds_size() const {
  return fileds_.size();
}
inline void command_hmltrim::clear_fileds() {
  fileds_.Clear();
}
inline const ::std::string& command_hmltrim::fileds(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmltrim.fileds)
  return fileds_.Get(index);
}
inline ::std::string* command_hmltrim::mutable_fileds(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmltrim.fileds)
  return fileds_.Mutable(index);
}
inline void command_hmltrim::set_fileds(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmltrim.fileds)
  fileds_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmltrim::set_fileds(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmltrim.fileds)
  fileds_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmltrim::set_fileds(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fileds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmltrim.fileds)
}
inline void command_hmltrim::set_fileds(int index, const char* value, size_t size) {
  fileds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmltrim.fileds)
}
inline ::std::string* command_hmltrim::add_fileds() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmltrim.fileds)
  return fileds_.Add();
}
inline void command_hmltrim::add_fileds(const ::std::string& value) {
  fileds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmltrim.fileds)
}
#if LANG_CXX11
inline void command_hmltrim::add_fileds(::std::string&& value) {
  fileds_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmltrim.fileds)
}
#endif
inline void command_hmltrim::add_fileds(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fileds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmltrim.fileds)
}
inline void command_hmltrim::add_fileds(const char* value, size_t size) {
  fileds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmltrim.fileds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmltrim::fileds() const {
  // @@protoc_insertion_point(field_list:client.command_hmltrim.fileds)
  return fileds_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmltrim::mutable_fileds() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmltrim.fileds)
  return &fileds_;
}

// int32 start = 3;
inline void command_hmltrim::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_hmltrim::start() const {
  // @@protoc_insertion_point(field_get:client.command_hmltrim.start)
  return start_;
}
inline void command_hmltrim::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_hmltrim.start)
}

// int32 stop = 4;
inline void command_hmltrim::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_hmltrim::stop() const {
  // @@protoc_insertion_point(field_get:client.command_hmltrim.stop)
  return stop_;
}
inline void command_hmltrim::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_hmltrim.stop)
}

// -------------------------------------------------------------------

// command_mhmltrim

// repeated string keys = 1;
inline int command_mhmltrim::keys_size() const {
  return keys_.size();
}
inline void command_mhmltrim::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmltrim::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmltrim.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmltrim::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmltrim.keys)
  return keys_.Mutable(index);
}
inline void command_mhmltrim::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmltrim.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmltrim::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmltrim.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmltrim::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmltrim.keys)
}
inline void command_mhmltrim::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmltrim.keys)
}
inline ::std::string* command_mhmltrim::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmltrim.keys)
  return keys_.Add();
}
inline void command_mhmltrim::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmltrim.keys)
}
#if LANG_CXX11
inline void command_mhmltrim::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmltrim.keys)
}
#endif
inline void command_mhmltrim::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmltrim.keys)
}
inline void command_mhmltrim::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmltrim.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmltrim::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmltrim.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmltrim::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmltrim.keys)
  return &keys_;
}

// repeated string fileds = 2;
inline int command_mhmltrim::fileds_size() const {
  return fileds_.size();
}
inline void command_mhmltrim::clear_fileds() {
  fileds_.Clear();
}
inline const ::std::string& command_mhmltrim::fileds(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmltrim.fileds)
  return fileds_.Get(index);
}
inline ::std::string* command_mhmltrim::mutable_fileds(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmltrim.fileds)
  return fileds_.Mutable(index);
}
inline void command_mhmltrim::set_fileds(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmltrim.fileds)
  fileds_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmltrim::set_fileds(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmltrim.fileds)
  fileds_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmltrim::set_fileds(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fileds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmltrim.fileds)
}
inline void command_mhmltrim::set_fileds(int index, const char* value, size_t size) {
  fileds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmltrim.fileds)
}
inline ::std::string* command_mhmltrim::add_fileds() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmltrim.fileds)
  return fileds_.Add();
}
inline void command_mhmltrim::add_fileds(const ::std::string& value) {
  fileds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmltrim.fileds)
}
#if LANG_CXX11
inline void command_mhmltrim::add_fileds(::std::string&& value) {
  fileds_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmltrim.fileds)
}
#endif
inline void command_mhmltrim::add_fileds(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fileds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmltrim.fileds)
}
inline void command_mhmltrim::add_fileds(const char* value, size_t size) {
  fileds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmltrim.fileds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmltrim::fileds() const {
  // @@protoc_insertion_point(field_list:client.command_mhmltrim.fileds)
  return fileds_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmltrim::mutable_fileds() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmltrim.fileds)
  return &fileds_;
}

// int32 start = 3;
inline void command_mhmltrim::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 command_mhmltrim::start() const {
  // @@protoc_insertion_point(field_get:client.command_mhmltrim.start)
  return start_;
}
inline void command_mhmltrim::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:client.command_mhmltrim.start)
}

// int32 stop = 4;
inline void command_mhmltrim::clear_stop() {
  stop_ = 0;
}
inline ::google::protobuf::int32 command_mhmltrim::stop() const {
  // @@protoc_insertion_point(field_get:client.command_mhmltrim.stop)
  return stop_;
}
inline void command_mhmltrim::set_stop(::google::protobuf::int32 value) {
  
  stop_ = value;
  // @@protoc_insertion_point(field_set:client.command_mhmltrim.stop)
}

// -------------------------------------------------------------------

// command_llen

// string key = 1;
inline void command_llen::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_llen::key() const {
  // @@protoc_insertion_point(field_get:client.command_llen.key)
  return key_.GetNoArena();
}
inline void command_llen::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_llen.key)
}
#if LANG_CXX11
inline void command_llen::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_llen.key)
}
#endif
inline void command_llen::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_llen.key)
}
inline void command_llen::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_llen.key)
}
inline ::std::string* command_llen::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_llen.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_llen::release_key() {
  // @@protoc_insertion_point(field_release:client.command_llen.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_llen::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_llen.key)
}

// -------------------------------------------------------------------

// command_llen_reply

// .client.command_reply state = 1;
inline bool command_llen_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_llen_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_llen_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_llen_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_llen_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_llen_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_llen_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_llen_reply.state)
  return state_;
}
inline void command_llen_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_llen_reply.state)
}

// .data.VALUE data = 2;
inline bool command_llen_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_llen_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_llen_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_llen_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_llen_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_llen_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_llen_reply.data)
  return data_;
}
inline void command_llen_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_llen_reply.data)
}

// -------------------------------------------------------------------

// command_mllen

// repeated string keys = 1;
inline int command_mllen::keys_size() const {
  return keys_.size();
}
inline void command_mllen::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mllen::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mllen.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mllen::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mllen.keys)
  return keys_.Mutable(index);
}
inline void command_mllen::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mllen.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mllen::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mllen.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mllen::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mllen.keys)
}
inline void command_mllen::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mllen.keys)
}
inline ::std::string* command_mllen::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mllen.keys)
  return keys_.Add();
}
inline void command_mllen::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mllen.keys)
}
#if LANG_CXX11
inline void command_mllen::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mllen.keys)
}
#endif
inline void command_mllen::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mllen.keys)
}
inline void command_mllen::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mllen.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mllen::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mllen.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mllen::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mllen.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// command_mllen_reply

// .client.command_reply state = 1;
inline bool command_mllen_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mllen_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mllen_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mllen_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mllen_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mllen_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mllen_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mllen_reply.state)
  return state_;
}
inline void command_mllen_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mllen_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_mllen_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_mllen_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mllen_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_mllen_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mllen_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_mllen_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mllen_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_mllen_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mllen_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_mllen_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mllen_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_hllen

// string key = 1;
inline void command_hllen::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hllen::key() const {
  // @@protoc_insertion_point(field_get:client.command_hllen.key)
  return key_.GetNoArena();
}
inline void command_hllen::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hllen.key)
}
#if LANG_CXX11
inline void command_hllen::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hllen.key)
}
#endif
inline void command_hllen::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hllen.key)
}
inline void command_hllen::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hllen.key)
}
inline ::std::string* command_hllen::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hllen.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hllen::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hllen.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hllen::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hllen.key)
}

// string field = 2;
inline void command_hllen::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hllen::field() const {
  // @@protoc_insertion_point(field_get:client.command_hllen.field)
  return field_.GetNoArena();
}
inline void command_hllen::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hllen.field)
}
#if LANG_CXX11
inline void command_hllen::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hllen.field)
}
#endif
inline void command_hllen::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hllen.field)
}
inline void command_hllen::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hllen.field)
}
inline ::std::string* command_hllen::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hllen.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hllen::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hllen.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hllen::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hllen.field)
}

// -------------------------------------------------------------------

// command_hllen_reply

// .client.command_reply state = 1;
inline bool command_hllen_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hllen_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hllen_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hllen_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hllen_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hllen_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hllen_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hllen_reply.state)
  return state_;
}
inline void command_hllen_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hllen_reply.state)
}

// .data.VALUE data = 2;
inline bool command_hllen_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_hllen_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_hllen_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hllen_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_hllen_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hllen_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hllen_reply.data)
  return data_;
}
inline void command_hllen_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_hllen_reply.data)
}

// -------------------------------------------------------------------

// command_hmllen

// string key = 1;
inline void command_hmllen::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmllen::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmllen.key)
  return key_.GetNoArena();
}
inline void command_hmllen::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmllen.key)
}
#if LANG_CXX11
inline void command_hmllen::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmllen.key)
}
#endif
inline void command_hmllen::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmllen.key)
}
inline void command_hmllen::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmllen.key)
}
inline ::std::string* command_hmllen::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmllen.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmllen::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmllen.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmllen::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmllen.key)
}

// repeated string fields = 2;
inline int command_hmllen::fields_size() const {
  return fields_.size();
}
inline void command_hmllen::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_hmllen::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmllen.fields)
  return fields_.Get(index);
}
inline ::std::string* command_hmllen::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmllen.fields)
  return fields_.Mutable(index);
}
inline void command_hmllen::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmllen.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmllen::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmllen.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmllen::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmllen.fields)
}
inline void command_hmllen::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmllen.fields)
}
inline ::std::string* command_hmllen::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmllen.fields)
  return fields_.Add();
}
inline void command_hmllen::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmllen.fields)
}
#if LANG_CXX11
inline void command_hmllen::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmllen.fields)
}
#endif
inline void command_hmllen::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmllen.fields)
}
inline void command_hmllen::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmllen.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmllen::fields() const {
  // @@protoc_insertion_point(field_list:client.command_hmllen.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmllen::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmllen.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_hmllen_reply

// .client.command_reply state = 1;
inline bool command_hmllen_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hmllen_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hmllen_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hmllen_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hmllen_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hmllen_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hmllen_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmllen_reply.state)
  return state_;
}
inline void command_hmllen_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmllen_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_hmllen_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_hmllen_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmllen_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_hmllen_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmllen_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_hmllen_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_hmllen_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_hmllen_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmllen_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_hmllen_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_hmllen_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mhmllen

// repeated string keys = 1;
inline int command_mhmllen::keys_size() const {
  return keys_.size();
}
inline void command_mhmllen::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmllen::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmllen.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmllen::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmllen.keys)
  return keys_.Mutable(index);
}
inline void command_mhmllen::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmllen.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmllen::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmllen.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmllen::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmllen.keys)
}
inline void command_mhmllen::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmllen.keys)
}
inline ::std::string* command_mhmllen::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmllen.keys)
  return keys_.Add();
}
inline void command_mhmllen::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmllen.keys)
}
#if LANG_CXX11
inline void command_mhmllen::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmllen.keys)
}
#endif
inline void command_mhmllen::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmllen.keys)
}
inline void command_mhmllen::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmllen.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmllen::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmllen.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmllen::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmllen.keys)
  return &keys_;
}

// repeated string fields = 2;
inline int command_mhmllen::fields_size() const {
  return fields_.size();
}
inline void command_mhmllen::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmllen::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmllen.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmllen::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmllen.fields)
  return fields_.Mutable(index);
}
inline void command_mhmllen::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmllen.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmllen::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmllen.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmllen::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmllen.fields)
}
inline void command_mhmllen::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmllen.fields)
}
inline ::std::string* command_mhmllen::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmllen.fields)
  return fields_.Add();
}
inline void command_mhmllen::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmllen.fields)
}
#if LANG_CXX11
inline void command_mhmllen::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmllen.fields)
}
#endif
inline void command_mhmllen::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmllen.fields)
}
inline void command_mhmllen::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmllen.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmllen::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmllen.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmllen::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmllen.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_mhmllen_reply

// .client.command_reply state = 1;
inline bool command_mhmllen_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mhmllen_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mhmllen_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mhmllen_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mhmllen_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mhmllen_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mhmllen_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mhmllen_reply.state)
  return state_;
}
inline void command_mhmllen_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mhmllen_reply.state)
}

// repeated .client.values_type data = 2;
inline int command_mhmllen_reply::data_size() const {
  return data_.size();
}
inline void command_mhmllen_reply::clear_data() {
  data_.Clear();
}
inline const ::client::values_type& command_mhmllen_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmllen_reply.data)
  return data_.Get(index);
}
inline ::client::values_type* command_mhmllen_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmllen_reply.data)
  return data_.Mutable(index);
}
inline ::client::values_type* command_mhmllen_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mhmllen_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::client::values_type >*
command_mhmllen_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmllen_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
command_mhmllen_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mhmllen_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mapget

// string key = 1;
inline void command_mapget::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_mapget::key() const {
  // @@protoc_insertion_point(field_get:client.command_mapget.key)
  return key_.GetNoArena();
}
inline void command_mapget::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_mapget.key)
}
#if LANG_CXX11
inline void command_mapget::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_mapget.key)
}
#endif
inline void command_mapget::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_mapget.key)
}
inline void command_mapget::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_mapget.key)
}
inline ::std::string* command_mapget::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_mapget.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_mapget::release_key() {
  // @@protoc_insertion_point(field_release:client.command_mapget.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_mapget::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_mapget.key)
}

// -------------------------------------------------------------------

// command_mapget_reply

// .client.command_reply state = 1;
inline bool command_mapget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mapget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mapget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mapget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mapget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mapget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mapget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mapget_reply.state)
  return state_;
}
inline void command_mapget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mapget_reply.state)
}

// .data.VALUE data = 2;
inline bool command_mapget_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_mapget_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_mapget_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_mapget_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_mapget_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_mapget_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mapget_reply.data)
  return data_;
}
inline void command_mapget_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_mapget_reply.data)
}

// -------------------------------------------------------------------

// command_mmapget

// repeated string keys = 1;
inline int command_mmapget::keys_size() const {
  return keys_.size();
}
inline void command_mmapget::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mmapget::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mmapget.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mmapget::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mmapget.keys)
  return keys_.Mutable(index);
}
inline void command_mmapget::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mmapget.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mmapget::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mmapget.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mmapget::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mmapget.keys)
}
inline void command_mmapget::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mmapget.keys)
}
inline ::std::string* command_mmapget::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mmapget.keys)
  return keys_.Add();
}
inline void command_mmapget::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mmapget.keys)
}
#if LANG_CXX11
inline void command_mmapget::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mmapget.keys)
}
#endif
inline void command_mmapget::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mmapget.keys)
}
inline void command_mmapget::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mmapget.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mmapget::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mmapget.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mmapget::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mmapget.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// command_mmapget_reply

// .client.command_reply state = 1;
inline bool command_mmapget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mmapget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mmapget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mmapget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mmapget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mmapget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mmapget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mmapget_reply.state)
  return state_;
}
inline void command_mmapget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mmapget_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_mmapget_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_mmapget_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mmapget_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_mmapget_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mmapget_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_mmapget_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mmapget_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_mmapget_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mmapget_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_mmapget_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mmapget_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_hmapget

// string key = 1;
inline void command_hmapget::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmapget::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmapget.key)
  return key_.GetNoArena();
}
inline void command_hmapget::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmapget.key)
}
#if LANG_CXX11
inline void command_hmapget::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmapget.key)
}
#endif
inline void command_hmapget::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmapget.key)
}
inline void command_hmapget::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapget.key)
}
inline ::std::string* command_hmapget::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmapget.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmapget::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmapget.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmapget::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapget.key)
}

// string field = 2;
inline void command_hmapget::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmapget::field() const {
  // @@protoc_insertion_point(field_get:client.command_hmapget.field)
  return field_.GetNoArena();
}
inline void command_hmapget::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmapget.field)
}
#if LANG_CXX11
inline void command_hmapget::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmapget.field)
}
#endif
inline void command_hmapget::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmapget.field)
}
inline void command_hmapget::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapget.field)
}
inline ::std::string* command_hmapget::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmapget.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmapget::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hmapget.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmapget::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapget.field)
}

// -------------------------------------------------------------------

// command_hmapget_reply

// .client.command_reply state = 1;
inline bool command_hmapget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hmapget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hmapget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hmapget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hmapget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hmapget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hmapget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmapget_reply.state)
  return state_;
}
inline void command_hmapget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapget_reply.state)
}

// .data.VALUE data = 2;
inline bool command_hmapget_reply::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::data::VALUE& command_hmapget_reply::data() const {
  const ::data::VALUE* p = data_;
  // @@protoc_insertion_point(field_get:client.command_hmapget_reply.data)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hmapget_reply::release_data() {
  // @@protoc_insertion_point(field_release:client.command_hmapget_reply.data)
  
  ::data::VALUE* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hmapget_reply::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmapget_reply.data)
  return data_;
}
inline void command_hmapget_reply::set_allocated_data(::data::VALUE* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapget_reply.data)
}

// -------------------------------------------------------------------

// command_hmmapget

// string key = 1;
inline void command_hmmapget::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmmapget::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmmapget.key)
  return key_.GetNoArena();
}
inline void command_hmmapget::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmmapget.key)
}
#if LANG_CXX11
inline void command_hmmapget::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmmapget.key)
}
#endif
inline void command_hmmapget::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmmapget.key)
}
inline void command_hmmapget::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmmapget.key)
}
inline ::std::string* command_hmmapget::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmmapget.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmmapget::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmmapget.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmmapget::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmmapget.key)
}

// repeated string fields = 2;
inline int command_hmmapget::fields_size() const {
  return fields_.size();
}
inline void command_hmmapget::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_hmmapget::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmmapget.fields)
  return fields_.Get(index);
}
inline ::std::string* command_hmmapget::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmmapget.fields)
  return fields_.Mutable(index);
}
inline void command_hmmapget::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmmapget.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmmapget::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmmapget.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmmapget::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmmapget.fields)
}
inline void command_hmmapget::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmmapget.fields)
}
inline ::std::string* command_hmmapget::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmmapget.fields)
  return fields_.Add();
}
inline void command_hmmapget::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmmapget.fields)
}
#if LANG_CXX11
inline void command_hmmapget::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmmapget.fields)
}
#endif
inline void command_hmmapget::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmmapget.fields)
}
inline void command_hmmapget::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmmapget.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmmapget::fields() const {
  // @@protoc_insertion_point(field_list:client.command_hmmapget.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmmapget::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmmapget.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_hmmapget_reply

// .client.command_reply state = 1;
inline bool command_hmmapget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_hmmapget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_hmmapget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_hmmapget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_hmmapget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_hmmapget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_hmmapget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmmapget_reply.state)
  return state_;
}
inline void command_hmmapget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmmapget_reply.state)
}

// repeated .data.VALUE data = 2;
inline int command_hmmapget_reply::data_size() const {
  return data_.size();
}
inline const ::data::VALUE& command_hmmapget_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmmapget_reply.data)
  return data_.Get(index);
}
inline ::data::VALUE* command_hmmapget_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmmapget_reply.data)
  return data_.Mutable(index);
}
inline ::data::VALUE* command_hmmapget_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_hmmapget_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::data::VALUE >*
command_hmmapget_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmmapget_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::data::VALUE >&
command_hmmapget_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_hmmapget_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mhmmapget

// repeated string keys = 1;
inline int command_mhmmapget::keys_size() const {
  return keys_.size();
}
inline void command_mhmmapget::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mhmmapget::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmmapget.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mhmmapget::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmmapget.keys)
  return keys_.Mutable(index);
}
inline void command_mhmmapget::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapget.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmmapget::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapget.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmmapget::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmmapget.keys)
}
inline void command_mhmmapget::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmmapget.keys)
}
inline ::std::string* command_mhmmapget::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmmapget.keys)
  return keys_.Add();
}
inline void command_mhmmapget::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmmapget.keys)
}
#if LANG_CXX11
inline void command_mhmmapget::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmmapget.keys)
}
#endif
inline void command_mhmmapget::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmmapget.keys)
}
inline void command_mhmmapget::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmmapget.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmmapget::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mhmmapget.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmmapget::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmmapget.keys)
  return &keys_;
}

// repeated string fields = 2;
inline int command_mhmmapget::fields_size() const {
  return fields_.size();
}
inline void command_mhmmapget::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmmapget::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmmapget.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmmapget::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmmapget.fields)
  return fields_.Mutable(index);
}
inline void command_mhmmapget::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapget.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmmapget::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapget.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmmapget::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmmapget.fields)
}
inline void command_mhmmapget::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmmapget.fields)
}
inline ::std::string* command_mhmmapget::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmmapget.fields)
  return fields_.Add();
}
inline void command_mhmmapget::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmmapget.fields)
}
#if LANG_CXX11
inline void command_mhmmapget::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmmapget.fields)
}
#endif
inline void command_mhmmapget::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmmapget.fields)
}
inline void command_mhmmapget::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmmapget.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmmapget::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmmapget.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmmapget::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmmapget.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// command_mhmmapget_reply

// .client.command_reply state = 1;
inline bool command_mhmmapget_reply::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void command_mhmmapget_reply::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::client::command_reply& command_mhmmapget_reply::state() const {
  const ::client::command_reply* p = state_;
  // @@protoc_insertion_point(field_get:client.command_mhmmapget_reply.state)
  return p != NULL ? *p : *reinterpret_cast<const ::client::command_reply*>(
      &::client::_command_reply_default_instance_);
}
inline ::client::command_reply* command_mhmmapget_reply::release_state() {
  // @@protoc_insertion_point(field_release:client.command_mhmmapget_reply.state)
  
  ::client::command_reply* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::client::command_reply* command_mhmmapget_reply::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::client::command_reply;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mhmmapget_reply.state)
  return state_;
}
inline void command_mhmmapget_reply::set_allocated_state(::client::command_reply* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:client.command_mhmmapget_reply.state)
}

// repeated .client.values_type data = 2;
inline int command_mhmmapget_reply::data_size() const {
  return data_.size();
}
inline void command_mhmmapget_reply::clear_data() {
  data_.Clear();
}
inline const ::client::values_type& command_mhmmapget_reply::data(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmmapget_reply.data)
  return data_.Get(index);
}
inline ::client::values_type* command_mhmmapget_reply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmmapget_reply.data)
  return data_.Mutable(index);
}
inline ::client::values_type* command_mhmmapget_reply::add_data() {
  // @@protoc_insertion_point(field_add:client.command_mhmmapget_reply.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::client::values_type >*
command_mhmmapget_reply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmmapget_reply.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::client::values_type >&
command_mhmmapget_reply::data() const {
  // @@protoc_insertion_point(field_list:client.command_mhmmapget_reply.data)
  return data_;
}

// -------------------------------------------------------------------

// command_mapset

// string key = 1;
inline void command_mapset::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_mapset::key() const {
  // @@protoc_insertion_point(field_get:client.command_mapset.key)
  return key_.GetNoArena();
}
inline void command_mapset::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_mapset.key)
}
#if LANG_CXX11
inline void command_mapset::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_mapset.key)
}
#endif
inline void command_mapset::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_mapset.key)
}
inline void command_mapset::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_mapset.key)
}
inline ::std::string* command_mapset::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_mapset.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_mapset::release_key() {
  // @@protoc_insertion_point(field_release:client.command_mapset.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_mapset::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_mapset.key)
}

// .data.VALUE value = 2;
inline bool command_mapset::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_mapset::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_mapset.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_mapset::release_value() {
  // @@protoc_insertion_point(field_release:client.command_mapset.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_mapset::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_mapset.value)
  return value_;
}
inline void command_mapset::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_mapset.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mmapset

// map<string, .data.VALUE> kvs = 1;
inline int command_mmapset::kvs_size() const {
  return kvs_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_mmapset::kvs() const {
  // @@protoc_insertion_point(field_map:client.command_mmapset.kvs)
  return kvs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_mmapset::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mmapset.kvs)
  return kvs_.MutableMap();
}

// -------------------------------------------------------------------

// command_hmapset

// string key = 1;
inline void command_hmapset::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmapset::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmapset.key)
  return key_.GetNoArena();
}
inline void command_hmapset::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmapset.key)
}
#if LANG_CXX11
inline void command_hmapset::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmapset.key)
}
#endif
inline void command_hmapset::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmapset.key)
}
inline void command_hmapset::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapset.key)
}
inline ::std::string* command_hmapset::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmapset.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmapset::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmapset.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmapset::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapset.key)
}

// string field = 2;
inline void command_hmapset::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmapset::field() const {
  // @@protoc_insertion_point(field_get:client.command_hmapset.field)
  return field_.GetNoArena();
}
inline void command_hmapset::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmapset.field)
}
#if LANG_CXX11
inline void command_hmapset::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmapset.field)
}
#endif
inline void command_hmapset::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmapset.field)
}
inline void command_hmapset::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapset.field)
}
inline ::std::string* command_hmapset::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmapset.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmapset::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hmapset.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmapset::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapset.field)
}

// .data.VALUE value = 3;
inline bool command_hmapset::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::data::VALUE& command_hmapset::value() const {
  const ::data::VALUE* p = value_;
  // @@protoc_insertion_point(field_get:client.command_hmapset.value)
  return p != NULL ? *p : *reinterpret_cast<const ::data::VALUE*>(
      &::data::_VALUE_default_instance_);
}
inline ::data::VALUE* command_hmapset::release_value() {
  // @@protoc_insertion_point(field_release:client.command_hmapset.value)
  
  ::data::VALUE* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::data::VALUE* command_hmapset::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::data::VALUE;
  }
  // @@protoc_insertion_point(field_mutable:client.command_hmapset.value)
  return value_;
}
inline void command_hmapset::set_allocated_value(::data::VALUE* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapset.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_hmmapset

// string key = 1;
inline void command_hmmapset::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmmapset::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmmapset.key)
  return key_.GetNoArena();
}
inline void command_hmmapset::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmmapset.key)
}
#if LANG_CXX11
inline void command_hmmapset::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmmapset.key)
}
#endif
inline void command_hmmapset::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmmapset.key)
}
inline void command_hmmapset::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmmapset.key)
}
inline ::std::string* command_hmmapset::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmmapset.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmmapset::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmmapset.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmmapset::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmmapset.key)
}

// map<string, .data.VALUE> values = 2;
inline int command_hmmapset::values_size() const {
  return values_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_hmmapset::values() const {
  // @@protoc_insertion_point(field_map:client.command_hmmapset.values)
  return values_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_hmmapset::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:client.command_hmmapset.values)
  return values_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mhmmapset

// repeated string fields = 1;
inline int command_mhmmapset::fields_size() const {
  return fields_.size();
}
inline void command_mhmmapset::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& command_mhmmapset::fields(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmmapset.fields)
  return fields_.Get(index);
}
inline ::std::string* command_mhmmapset::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmmapset.fields)
  return fields_.Mutable(index);
}
inline void command_mhmmapset::set_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapset.fields)
  fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmmapset::set_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapset.fields)
  fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmmapset::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmmapset.fields)
}
inline void command_mhmmapset::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmmapset.fields)
}
inline ::std::string* command_mhmmapset::add_fields() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmmapset.fields)
  return fields_.Add();
}
inline void command_mhmmapset::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmmapset.fields)
}
#if LANG_CXX11
inline void command_mhmmapset::add_fields(::std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmmapset.fields)
}
#endif
inline void command_mhmmapset::add_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmmapset.fields)
}
inline void command_mhmmapset::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmmapset.fields)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmmapset::fields() const {
  // @@protoc_insertion_point(field_list:client.command_mhmmapset.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmmapset::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmmapset.fields)
  return &fields_;
}

// map<string, .data.VALUE> values = 2;
inline int command_mhmmapset::values_size() const {
  return values_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::data::VALUE >&
command_mhmmapset::values() const {
  // @@protoc_insertion_point(field_map:client.command_mhmmapset.values)
  return values_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::data::VALUE >*
command_mhmmapset::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mhmmapset.values)
  return values_.MutableMap();
}

// -------------------------------------------------------------------

// command_mapdel

// string key = 1;
inline void command_mapdel::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_mapdel::key() const {
  // @@protoc_insertion_point(field_get:client.command_mapdel.key)
  return key_.GetNoArena();
}
inline void command_mapdel::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_mapdel.key)
}
#if LANG_CXX11
inline void command_mapdel::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_mapdel.key)
}
#endif
inline void command_mapdel::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_mapdel.key)
}
inline void command_mapdel::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_mapdel.key)
}
inline ::std::string* command_mapdel::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_mapdel.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_mapdel::release_key() {
  // @@protoc_insertion_point(field_release:client.command_mapdel.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_mapdel::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_mapdel.key)
}

// repeated string mapkeys = 2;
inline int command_mapdel::mapkeys_size() const {
  return mapkeys_.size();
}
inline void command_mapdel::clear_mapkeys() {
  mapkeys_.Clear();
}
inline const ::std::string& command_mapdel::mapkeys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mapdel.mapkeys)
  return mapkeys_.Get(index);
}
inline ::std::string* command_mapdel::mutable_mapkeys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mapdel.mapkeys)
  return mapkeys_.Mutable(index);
}
inline void command_mapdel::set_mapkeys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mapdel::set_mapkeys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mapdel::set_mapkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mapdel.mapkeys)
}
inline void command_mapdel::set_mapkeys(int index, const char* value, size_t size) {
  mapkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mapdel.mapkeys)
}
inline ::std::string* command_mapdel::add_mapkeys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mapdel.mapkeys)
  return mapkeys_.Add();
}
inline void command_mapdel::add_mapkeys(const ::std::string& value) {
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mapdel.mapkeys)
}
#if LANG_CXX11
inline void command_mapdel::add_mapkeys(::std::string&& value) {
  mapkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mapdel.mapkeys)
}
#endif
inline void command_mapdel::add_mapkeys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mapdel.mapkeys)
}
inline void command_mapdel::add_mapkeys(const char* value, size_t size) {
  mapkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mapdel.mapkeys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mapdel::mapkeys() const {
  // @@protoc_insertion_point(field_list:client.command_mapdel.mapkeys)
  return mapkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mapdel::mutable_mapkeys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mapdel.mapkeys)
  return &mapkeys_;
}

// -------------------------------------------------------------------

// command_mmapdel

// repeated string keys = 1;
inline int command_mmapdel::keys_size() const {
  return keys_.size();
}
inline void command_mmapdel::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& command_mmapdel::keys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mmapdel.keys)
  return keys_.Get(index);
}
inline ::std::string* command_mmapdel::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mmapdel.keys)
  return keys_.Mutable(index);
}
inline void command_mmapdel::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mmapdel.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mmapdel::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mmapdel.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mmapdel::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mmapdel.keys)
}
inline void command_mmapdel::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mmapdel.keys)
}
inline ::std::string* command_mmapdel::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mmapdel.keys)
  return keys_.Add();
}
inline void command_mmapdel::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mmapdel.keys)
}
#if LANG_CXX11
inline void command_mmapdel::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mmapdel.keys)
}
#endif
inline void command_mmapdel::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mmapdel.keys)
}
inline void command_mmapdel::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mmapdel.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mmapdel::keys() const {
  // @@protoc_insertion_point(field_list:client.command_mmapdel.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mmapdel::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mmapdel.keys)
  return &keys_;
}

// repeated string mapkeys = 2;
inline int command_mmapdel::mapkeys_size() const {
  return mapkeys_.size();
}
inline void command_mmapdel::clear_mapkeys() {
  mapkeys_.Clear();
}
inline const ::std::string& command_mmapdel::mapkeys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mmapdel.mapkeys)
  return mapkeys_.Get(index);
}
inline ::std::string* command_mmapdel::mutable_mapkeys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mmapdel.mapkeys)
  return mapkeys_.Mutable(index);
}
inline void command_mmapdel::set_mapkeys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mmapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mmapdel::set_mapkeys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mmapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mmapdel::set_mapkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mmapdel.mapkeys)
}
inline void command_mmapdel::set_mapkeys(int index, const char* value, size_t size) {
  mapkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mmapdel.mapkeys)
}
inline ::std::string* command_mmapdel::add_mapkeys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mmapdel.mapkeys)
  return mapkeys_.Add();
}
inline void command_mmapdel::add_mapkeys(const ::std::string& value) {
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mmapdel.mapkeys)
}
#if LANG_CXX11
inline void command_mmapdel::add_mapkeys(::std::string&& value) {
  mapkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mmapdel.mapkeys)
}
#endif
inline void command_mmapdel::add_mapkeys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mmapdel.mapkeys)
}
inline void command_mmapdel::add_mapkeys(const char* value, size_t size) {
  mapkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mmapdel.mapkeys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mmapdel::mapkeys() const {
  // @@protoc_insertion_point(field_list:client.command_mmapdel.mapkeys)
  return mapkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mmapdel::mutable_mapkeys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mmapdel.mapkeys)
  return &mapkeys_;
}

// -------------------------------------------------------------------

// command_hmapdel

// string key = 1;
inline void command_hmapdel::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmapdel::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmapdel.key)
  return key_.GetNoArena();
}
inline void command_hmapdel::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmapdel.key)
}
#if LANG_CXX11
inline void command_hmapdel::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmapdel.key)
}
#endif
inline void command_hmapdel::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmapdel.key)
}
inline void command_hmapdel::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapdel.key)
}
inline ::std::string* command_hmapdel::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmapdel.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmapdel::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmapdel.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmapdel::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapdel.key)
}

// string field = 2;
inline void command_hmapdel::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmapdel::field() const {
  // @@protoc_insertion_point(field_get:client.command_hmapdel.field)
  return field_.GetNoArena();
}
inline void command_hmapdel::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmapdel.field)
}
#if LANG_CXX11
inline void command_hmapdel::set_field(::std::string&& value) {
  
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmapdel.field)
}
#endif
inline void command_hmapdel::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmapdel.field)
}
inline void command_hmapdel::set_field(const char* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapdel.field)
}
inline ::std::string* command_hmapdel::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmapdel.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmapdel::release_field() {
  // @@protoc_insertion_point(field_release:client.command_hmapdel.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmapdel::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmapdel.field)
}

// repeated string mapkeys = 3;
inline int command_hmapdel::mapkeys_size() const {
  return mapkeys_.size();
}
inline void command_hmapdel::clear_mapkeys() {
  mapkeys_.Clear();
}
inline const ::std::string& command_hmapdel::mapkeys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmapdel.mapkeys)
  return mapkeys_.Get(index);
}
inline ::std::string* command_hmapdel::mutable_mapkeys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmapdel.mapkeys)
  return mapkeys_.Mutable(index);
}
inline void command_hmapdel::set_mapkeys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmapdel::set_mapkeys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmapdel::set_mapkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmapdel.mapkeys)
}
inline void command_hmapdel::set_mapkeys(int index, const char* value, size_t size) {
  mapkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmapdel.mapkeys)
}
inline ::std::string* command_hmapdel::add_mapkeys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmapdel.mapkeys)
  return mapkeys_.Add();
}
inline void command_hmapdel::add_mapkeys(const ::std::string& value) {
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmapdel.mapkeys)
}
#if LANG_CXX11
inline void command_hmapdel::add_mapkeys(::std::string&& value) {
  mapkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmapdel.mapkeys)
}
#endif
inline void command_hmapdel::add_mapkeys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmapdel.mapkeys)
}
inline void command_hmapdel::add_mapkeys(const char* value, size_t size) {
  mapkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmapdel.mapkeys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmapdel::mapkeys() const {
  // @@protoc_insertion_point(field_list:client.command_hmapdel.mapkeys)
  return mapkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmapdel::mutable_mapkeys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmapdel.mapkeys)
  return &mapkeys_;
}

// -------------------------------------------------------------------

// command_hmmapdel

// string key = 1;
inline void command_hmmapdel::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_hmmapdel::key() const {
  // @@protoc_insertion_point(field_get:client.command_hmmapdel.key)
  return key_.GetNoArena();
}
inline void command_hmmapdel::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_hmmapdel.key)
}
#if LANG_CXX11
inline void command_hmmapdel::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_hmmapdel.key)
}
#endif
inline void command_hmmapdel::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_hmmapdel.key)
}
inline void command_hmmapdel::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_hmmapdel.key)
}
inline ::std::string* command_hmmapdel::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:client.command_hmmapdel.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_hmmapdel::release_key() {
  // @@protoc_insertion_point(field_release:client.command_hmmapdel.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_hmmapdel::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:client.command_hmmapdel.key)
}

// repeated string field = 2;
inline int command_hmmapdel::field_size() const {
  return field_.size();
}
inline void command_hmmapdel::clear_field() {
  field_.Clear();
}
inline const ::std::string& command_hmmapdel::field(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmmapdel.field)
  return field_.Get(index);
}
inline ::std::string* command_hmmapdel::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmmapdel.field)
  return field_.Mutable(index);
}
inline void command_hmmapdel::set_field(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmmapdel.field)
  field_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmmapdel::set_field(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmmapdel.field)
  field_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmmapdel::set_field(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmmapdel.field)
}
inline void command_hmmapdel::set_field(int index, const char* value, size_t size) {
  field_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmmapdel.field)
}
inline ::std::string* command_hmmapdel::add_field() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmmapdel.field)
  return field_.Add();
}
inline void command_hmmapdel::add_field(const ::std::string& value) {
  field_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmmapdel.field)
}
#if LANG_CXX11
inline void command_hmmapdel::add_field(::std::string&& value) {
  field_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmmapdel.field)
}
#endif
inline void command_hmmapdel::add_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmmapdel.field)
}
inline void command_hmmapdel::add_field(const char* value, size_t size) {
  field_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmmapdel.field)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmmapdel::field() const {
  // @@protoc_insertion_point(field_list:client.command_hmmapdel.field)
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmmapdel::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmmapdel.field)
  return &field_;
}

// repeated string mapkeys = 3;
inline int command_hmmapdel::mapkeys_size() const {
  return mapkeys_.size();
}
inline void command_hmmapdel::clear_mapkeys() {
  mapkeys_.Clear();
}
inline const ::std::string& command_hmmapdel::mapkeys(int index) const {
  // @@protoc_insertion_point(field_get:client.command_hmmapdel.mapkeys)
  return mapkeys_.Get(index);
}
inline ::std::string* command_hmmapdel::mutable_mapkeys(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_hmmapdel.mapkeys)
  return mapkeys_.Mutable(index);
}
inline void command_hmmapdel::set_mapkeys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_hmmapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_hmmapdel::set_mapkeys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_hmmapdel.mapkeys)
  mapkeys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_hmmapdel::set_mapkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_hmmapdel.mapkeys)
}
inline void command_hmmapdel::set_mapkeys(int index, const char* value, size_t size) {
  mapkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_hmmapdel.mapkeys)
}
inline ::std::string* command_hmmapdel::add_mapkeys() {
  // @@protoc_insertion_point(field_add_mutable:client.command_hmmapdel.mapkeys)
  return mapkeys_.Add();
}
inline void command_hmmapdel::add_mapkeys(const ::std::string& value) {
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_hmmapdel.mapkeys)
}
#if LANG_CXX11
inline void command_hmmapdel::add_mapkeys(::std::string&& value) {
  mapkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_hmmapdel.mapkeys)
}
#endif
inline void command_hmmapdel::add_mapkeys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_hmmapdel.mapkeys)
}
inline void command_hmmapdel::add_mapkeys(const char* value, size_t size) {
  mapkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_hmmapdel.mapkeys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_hmmapdel::mapkeys() const {
  // @@protoc_insertion_point(field_list:client.command_hmmapdel.mapkeys)
  return mapkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_hmmapdel::mutable_mapkeys() {
  // @@protoc_insertion_point(field_mutable_list:client.command_hmmapdel.mapkeys)
  return &mapkeys_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command_mhmmapdel

// repeated string field = 1;
inline int command_mhmmapdel::field_size() const {
  return field_.size();
}
inline void command_mhmmapdel::clear_field() {
  field_.Clear();
}
inline const ::std::string& command_mhmmapdel::field(int index) const {
  // @@protoc_insertion_point(field_get:client.command_mhmmapdel.field)
  return field_.Get(index);
}
inline ::std::string* command_mhmmapdel::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:client.command_mhmmapdel.field)
  return field_.Mutable(index);
}
inline void command_mhmmapdel::set_field(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapdel.field)
  field_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void command_mhmmapdel::set_field(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:client.command_mhmmapdel.field)
  field_.Mutable(index)->assign(std::move(value));
}
#endif
inline void command_mhmmapdel::set_field(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:client.command_mhmmapdel.field)
}
inline void command_mhmmapdel::set_field(int index, const char* value, size_t size) {
  field_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:client.command_mhmmapdel.field)
}
inline ::std::string* command_mhmmapdel::add_field() {
  // @@protoc_insertion_point(field_add_mutable:client.command_mhmmapdel.field)
  return field_.Add();
}
inline void command_mhmmapdel::add_field(const ::std::string& value) {
  field_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:client.command_mhmmapdel.field)
}
#if LANG_CXX11
inline void command_mhmmapdel::add_field(::std::string&& value) {
  field_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:client.command_mhmmapdel.field)
}
#endif
inline void command_mhmmapdel::add_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:client.command_mhmmapdel.field)
}
inline void command_mhmmapdel::add_field(const char* value, size_t size) {
  field_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:client.command_mhmmapdel.field)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
command_mhmmapdel::field() const {
  // @@protoc_insertion_point(field_list:client.command_mhmmapdel.field)
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
command_mhmmapdel::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:client.command_mhmmapdel.field)
  return &field_;
}

// map<string, .client.keys_type> values = 2;
inline int command_mhmmapdel::values_size() const {
  return values_.size();
}
inline void command_mhmmapdel::clear_values() {
  values_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::client::keys_type >&
command_mhmmapdel::values() const {
  // @@protoc_insertion_point(field_map:client.command_mhmmapdel.values)
  return values_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::client::keys_type >*
command_mhmmapdel::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:client.command_mhmmapdel.values)
  return values_.MutableMap();
}

// -------------------------------------------------------------------

// command_meet

// string ip = 1;
inline void command_meet::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& command_meet::ip() const {
  // @@protoc_insertion_point(field_get:client.command_meet.ip)
  return ip_.GetNoArena();
}
inline void command_meet::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:client.command_meet.ip)
}
#if LANG_CXX11
inline void command_meet::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client.command_meet.ip)
}
#endif
inline void command_meet::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client.command_meet.ip)
}
inline void command_meet::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client.command_meet.ip)
}
inline ::std::string* command_meet::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:client.command_meet.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_meet::release_ip() {
  // @@protoc_insertion_point(field_release:client.command_meet.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_meet::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:client.command_meet.ip)
}

// int64 port = 2;
inline void command_meet::clear_port() {
  port_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 command_meet::port() const {
  // @@protoc_insertion_point(field_get:client.command_meet.port)
  return port_;
}
inline void command_meet::set_port(::google::protobuf::int64 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:client.command_meet.port)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::client::type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::type>() {
  return ::client::type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
